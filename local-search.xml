<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Reflect 的作用</title>
    <link href="/js/relfect/"/>
    <url>/js/relfect/</url>
    
    <content type="html"><![CDATA[<h1 id="Reflect-的作用"><a href="#Reflect-的作用" class="headerlink" title="Reflect 的作用"></a>Reflect 的作用</h1><p>这个对象一般都是和 <code>Proxy</code> 配合使用的，这里就不多介绍 <code>Proxy</code> 了。<br>在学 <code>Reflect</code> 时候很疑惑，为什么要用这个对象，获取对象属性不是可以通过 <code>obj.name</code> 直接获取吗？为什么要多此一举去使用 <code>Reflect.get(obj, name)</code>来获取呢？</p><p>我们首先来看看 Reflect 的基本使用。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">mdn-Reflect</a></p><p>基本描述：<code>Reflec</code>t 是一个内置的对象，它提供拦截 JavaScript 操作的方法。<br>如何获取属性：<code>Reflect.get(target, propertyKey[, receiver])</code></p><ul><li>target：需要取值的目标对象。</li><li>propertyKey：需要获取的值的键值。</li></ul><p>上面两个都好理解，那 <code>receiver</code> 是干嘛的，官方的介绍（如果 <code>target</code> 对象中指定了 <code>getter</code>，<code>receiver</code> 则为 <code>getter</code> 调用时的 <code>this</code> 值。），通俗来说，就是 <code>receiver</code> 可以指定 <code>getter</code> 中的 <code>this 指向</code>。</p><h2 id="体验一下-receiver-的作用"><a href="#体验一下-receiver-的作用" class="headerlink" title="体验一下 receiver 的作用"></a>体验一下 receiver 的作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> info1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">getInfo</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> info2 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">getInfo</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(info1.<span class="hljs-property">getInfo</span>); <span class="hljs-comment">// 张三22</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(info1, <span class="hljs-string">&quot;getInfo&quot;</span>)); <span class="hljs-comment">// 张三22</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(info1, <span class="hljs-string">&quot;getInfo&quot;</span>, info2)); <span class="hljs-comment">// chenjiang25</span><br></code></pre></td></tr></table></figure><p>前两个打印都好理解，第三个为什么是 <code>chenjiang25</code>，上面提到了 <code>receiver</code> 这个属性指定了 <code>getter</code> 中 <code>this</code> 的指向，因此 <code>info1</code> 中 <code>getInfo</code> 方法里面的 <code>this 是 receiver</code>，也就是 <code>info2</code>，所以才是这个结果。</p><h2 id="深一步的去了解-receiver"><a href="#深一步的去了解-receiver" class="headerlink" title="深一步的去了解 receiver"></a>深一步的去了解 receiver</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> info1 = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">22</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">getInfo</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(info1, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getter 被触发了&quot;</span>);<br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">getInfo</span>);<br><br><span class="hljs-comment">//------------打印结果----------------</span><br><span class="hljs-comment">// getter 被触发了</span><br><span class="hljs-comment">// 张三22</span><br></code></pre></td></tr></table></figure><p>我们从结果来看 <code>getter</code> 触发了一次，按理来说，应该触发三次，获取 <code>getInfo</code> 时候一次，内部 <code>this.name</code> 两次，<code>this.age</code> 三次，最终应该触发了三次 <code>getter</code>，那为什么只触发了一次，是因为 <code>proxy.getInfo</code> 是获取代理对象的属性，因此只会触发 <code>proxy</code> 的 <code>getter</code>。</p><p>如何才能让它触发三次，其实很简单，只需要修改 <code>getInfo</code> 内部的 <code>this</code> 指向。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(info1, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;getter 被触发了&quot;</span>);<br>    <span class="hljs-comment">// 改变 info1 的 getter 里面 this 的指向，指向 proxy，这样获取属性，就可以触发 proxy 的 getter。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(info1, <span class="hljs-string">&quot;getInfo&quot;</span>, receiver);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当我们期望监听代理对象的 <code>getter</code> 和 <code>setter</code> 时候，不应该使用 target[key]，因为它在某些时候是不可靠的（例如：上面的 <code>getInfo</code>），而应该使用 <code>Reflect</code>，借助它的 <code>get</code> 和 <code>set</code> 方法，使用 <code>receiver</code> 作为 <code>this</code>，达到期望结果（上面的触发三次 <code>getter</code>）。</p><p>这也就证实了文章开头所说的为什么<code>Proxy</code>要配合<code>Reflect</code>来使用，因为一旦我们在被代理对象的内部，通过<code>this</code>触发<code>getter</code>或者<code>setter</code>，也需要被监听到。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大文件上传逻辑梳理</title>
    <link href="/scene/big-file-upload/"/>
    <url>/scene/big-file-upload/</url>
    
    <content type="html"><![CDATA[<h1 id="大文件上传逻辑梳理"><a href="#大文件上传逻辑梳理" class="headerlink" title="大文件上传逻辑梳理"></a>大文件上传逻辑梳理</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果文件太大，比如一个视频几个 G，直接上传，可能出现连接超时，也存在超过服务器允许上传文件的大小限制。</p><p>为了解决这个问题，我们可以将大文件进行分片上传，每次只用上传很小的一部分，然后再有后端去组装这些分片，就可以形成一个完整的文件。</p><h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><ul><li>前端将大文件切片，拆分成一个一个的<code>chunk</code>。</li><li>将切片传递给后端，每个切片都带有唯一标识（hash）和索引值（index），以便于后端处理。</li><li>后端将切片进行组合。</li></ul><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>文件采用 Blob 格式，它表示原始数据，也就是二进制数据，同时提供了对数据截取的方法<code>slice</code>，而 File 继承了<code>Blob</code>的功能，所以可以直接使用此方法对数据进行分段。</p><p>整体流程：</p><ul><li>将大文件进行分段，发送到服务器时携带一个标志，用于标识一个完整的文件。</li><li>服务端保存各段文件。</li><li>浏览器所有分片上传完成，给服务器发送一个合并文件的请求。</li><li>服务器根据文件标识、类型、各分片顺序进行文件合并。</li><li>删除分片文件。</li></ul><h3 id="前端逻辑实现"><a href="#前端逻辑实现" class="headerlink" title="前端逻辑实现"></a>前端逻辑实现</h3><p><strong>前端布局</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;upload&quot;</span>&gt;</span>上传<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>文件切片</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;input&quot;</span>);<br><span class="hljs-keyword">let</span> upload = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;upload&quot;</span>);<br><span class="hljs-keyword">let</span> files = &#123;&#125;; <span class="hljs-comment">//创建一个文件对象</span><br><span class="hljs-keyword">let</span> chunkList = []; <span class="hljs-comment">//存放切片的数组</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建切片</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; file 大文件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">*</span>&#125; size 切片文件大小</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">createChunk</span> = (<span class="hljs-params">file, size = <span class="hljs-number">2</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> chunkList = [];<br>  <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// 切出大小为size的切片</span><br>  <span class="hljs-keyword">while</span> (cur &lt; file.<span class="hljs-property">size</span>) &#123;<br>    chunkList.<span class="hljs-title function_">push</span>(&#123;<br>      <span class="hljs-attr">file</span>: file.<span class="hljs-title function_">slice</span>(cur, cur + size),<br>    &#125;);<br><br>    cur += size;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> chunkList;<br>&#125;;<br><br><span class="hljs-comment">// 读取文件</span><br>input.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;change&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  files = e.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>];<br>  <span class="hljs-comment">// 创建切片</span><br>  chunkList = <span class="hljs-title function_">createChunk</span>(files);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>上传切片</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 数据处理，将切片数据包装成表单类型数据，才能传递给后端</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">uploadFile</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">list</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> requestList = list<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">&#123; file, fileName, chunkName, totalPart, currentPart &#125;</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 创建表单类型数据，便于传给后端</span><br>      <span class="hljs-keyword">const</span> formData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FormData</span>();<br>      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;fileName&quot;</span>, fileName);<br>      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;chunkName&quot;</span>, chunkName);<br>      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;totalPart&quot;</span>, totalPart);<br>      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;currentPart&quot;</span>, currentPart);<br>      formData.<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;file&quot;</span>, file);<br>      <span class="hljs-keyword">return</span> formData;<br>    &#125;)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">formData</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;http://localhost:5000/upload&quot;</span>, formData, &#123;<br>        <span class="hljs-attr">headers</span>: <span class="hljs-string">&quot;Content-Type:application/x-www-form-urlencoded&quot;</span>,<br>      &#125;);<br>    &#125;);<br>&#125;;<br><br>upload.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 每个切片都需要做处理，添加相关信息，这个也就是需要上传的切片</span><br>  <span class="hljs-keyword">const</span> uploadList = chunkList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">&#123; file &#125;, index</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      file, <span class="hljs-comment">// 切片信息</span><br>      <span class="hljs-attr">size</span>: file.<span class="hljs-property">size</span>, <span class="hljs-comment">// 切片大小</span><br>      <span class="hljs-attr">fileName</span>: files.<span class="hljs-property">name</span>, <span class="hljs-comment">// 完整大文件的名称</span><br>      <span class="hljs-attr">chunkName</span>: <span class="hljs-string">`<span class="hljs-subst">$&#123;files.name&#125;</span>-<span class="hljs-subst">$&#123;index&#125;</span>`</span>, <span class="hljs-comment">// 切片名称</span><br>      <span class="hljs-attr">totalPart</span>: chunkList.<span class="hljs-property">length</span>, <span class="hljs-comment">// 总共有多少个chunk</span><br>      <span class="hljs-attr">currentPart</span>: index + <span class="hljs-number">1</span>, <span class="hljs-comment">// 当前切片索引</span><br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-comment">// 执行上传函数</span><br>  <span class="hljs-title function_">uploadFile</span>(uploadList);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="后端逻辑实现"><a href="#后端逻辑实现" class="headerlink" title="后端逻辑实现"></a>后端逻辑实现</h3><p>整体过程：</p><ul><li>创建写入流</li><li>将切片转换成流</li><li>将切片流追加到写入流中</li><li>删除已经读取过的切片</li><li>将合并完成后的写入流生成对应的文件</li></ul><p><strong>将前端传过来的切片保存到磁盘</strong><br>这里采用了<code>multer</code>npm 包，更好的去处理<code>FormData</code>数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> storage = multer.<span class="hljs-title function_">diskStorage</span>(&#123;<br>  <span class="hljs-attr">destination</span>: <span class="hljs-function">(<span class="hljs-params">req, file, cb</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 存储到uploads目录</span><br>    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, uploadDir);<br>  &#125;,<br>  <span class="hljs-attr">filename</span>: <span class="hljs-function">(<span class="hljs-params">req, file, cb</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取文件名和切片编号</span><br>    <span class="hljs-keyword">const</span> &#123; fileName, currentPart &#125; = req.<span class="hljs-property">body</span>;<br>    <span class="hljs-title function_">cb</span>(<span class="hljs-literal">null</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;fileName&#125;</span>.part-<span class="hljs-subst">$&#123;currentPart&#125;</span>`</span>);<br>  &#125;,<br>&#125;);<br><br><span class="hljs-keyword">const</span> upload = <span class="hljs-title function_">multer</span>(&#123; storage &#125;);<br><br><span class="hljs-comment">// upload.single(&quot;file&quot;) 表示存储FormData中名为&quot;file&quot;的文件</span><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/upload&quot;</span>, upload.<span class="hljs-title function_">single</span>(<span class="hljs-string">&quot;file&quot;</span>), <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; fileName, totalPart, currentPart &#125; = req.<span class="hljs-property">body</span>;<br><br>  <span class="hljs-comment">// 如果是最后一个切片，开始合并文件</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(totalPart) === <span class="hljs-built_in">parseInt</span>(currentPart)) &#123;<br>    <span class="hljs-title function_">mergeFileChunk</span>(fileName, totalPart);<br>  &#125;<br><br>  res.<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">json</span>(&#123; <span class="hljs-attr">message</span>: <span class="hljs-string">`当前第<span class="hljs-subst">$&#123;currentPart&#125;</span>切片上传完毕！！！`</span> &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>读取切片、转换成文件流、将切片流追加到写入流</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">mergeFileChunk</span>(<span class="hljs-params">fileName, totalPart</span>) &#123;<br>  <span class="hljs-keyword">const</span> writeStream = fse.<span class="hljs-title function_">createWriteStream</span>(path.<span class="hljs-title function_">join</span>(uploadDir, fileName));<br>  <span class="hljs-keyword">let</span> partIndex = <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">while</span> (partIndex &lt;= totalPart) &#123;<br>    <span class="hljs-keyword">const</span> partFilePath = path.<span class="hljs-title function_">join</span>(uploadDir, <span class="hljs-string">`<span class="hljs-subst">$&#123;fileName&#125;</span>.part-<span class="hljs-subst">$&#123;partIndex&#125;</span>`</span>);<br>    <span class="hljs-keyword">if</span> (fse.<span class="hljs-title function_">existsSync</span>(partFilePath)) &#123;<br>      <span class="hljs-keyword">const</span> partStream = fse.<span class="hljs-title function_">createReadStream</span>(partFilePath);<br>      partStream.<span class="hljs-title function_">pipe</span>(writeStream, &#123; <span class="hljs-attr">end</span>: <span class="hljs-literal">false</span> &#125;);<br><br>      <span class="hljs-comment">// 等待当前切片完成后，再处理下一个切片</span><br>      <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        partStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;end&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-comment">// 此切片已经读取了（或者说已经合并完成），需要删除</span><br>          fse.<span class="hljs-title function_">unlinkSync</span>(partFilePath);<br>          <span class="hljs-title function_">resolve</span>();<br>        &#125;);<br><br>        partStream.<span class="hljs-title function_">on</span>(<span class="hljs-string">&quot;error&quot;</span>, reject);<br>      &#125;);<br><br>      partIndex++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 某个切片不存在，跳出循环</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 合并完成</span><br>  writeStream.<span class="hljs-title function_">end</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;合并完成！！！&quot;</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><ul><li>前端切片：主线程去做切片卡顿，可以借助<code>web-worker</code>多线程切片，处理完成后交给主线程发送。</li><li>切片完成后，发送给后端，并将<code>blob</code>存储到<code>IndexedDB</code>（为了防止切片完成，用户关闭了浏览器，导致切片丢失），用户下次进来之后，可以嗅探一下是否存在未上传的切片，如果有就继续上传。</li></ul><p><font color="gray">待更新：断点续传、秒传</font></p><p>参考文章：</p><ul><li><a href="https://juejin.cn/post/7177045936298786872">https://juejin.cn/post/7177045936298786872</a></li><li><a href="https://juejin.cn/post/7078583109419008013">https://juejin.cn/post/7078583109419008013</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>场景题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS大数如何处理</title>
    <link href="/js/js-bigInt/"/>
    <url>/js/js-bigInt/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-大数如何处理"><a href="#JS-大数如何处理" class="headerlink" title="JS 大数如何处理"></a>JS 大数如何处理</h1><p>在 JavaScript 中，超过<code>Number.MAX_VALUE</code>的数值被认为<code>Infinity</code>（正无穷大）。如果要处理超过<code>Number.MAX_VALUE</code>的数值，可以使用第三方库，例如：big.js、bigNumber.js、decimal.js 等库，可以处理任意进度的数值，或者使用 BigInt 数据类型。</p><h2 id="不依赖外部库，如何处理"><a href="#不依赖外部库，如何处理" class="headerlink" title="不依赖外部库，如何处理"></a>不依赖外部库，如何处理</h2><p>当数值超过<code>MAX_VALUE</code>时，可以使用<code>BigInt</code>类型来处理，它可以表示任意进度的整数。<br>注：使用<code>BigInt</code>类型时，需要在数值后面添加一个<code>n</code>来表示<code>BigInt</code>类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 注意这个后缀n</span><br><span class="hljs-keyword">const</span> bigNum = <span class="hljs-number">71894739127493712974892174n</span>;<br></code></pre></td></tr></table></figure><h2 id="依赖外部库bignumber-js"><a href="#依赖外部库bignumber-js" class="headerlink" title="依赖外部库bignumber.js"></a>依赖外部库<code>bignumber.js</code></h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>; <span class="hljs-comment">// 0.30000000000000004</span><br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNumber</span>(<span class="hljs-number">0.1</span>);<br>y = x.<span class="hljs-title function_">plus</span>(<span class="hljs-number">0.2</span>); <span class="hljs-comment">// &#x27;0.3&#x27;</span><br><br><span class="hljs-number">0.3</span> - <span class="hljs-number">0.1</span>; <span class="hljs-comment">// 0.19999999999999998</span><br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigNumber</span>(<span class="hljs-number">0.3</span>);<br>x.<span class="hljs-title function_">minus</span>(<span class="hljs-number">0.1</span>); <span class="hljs-comment">// &#x27;0.2&#x27;</span><br></code></pre></td></tr></table></figure><div class="note note-primary">            <p>以上都是以技术层面上去处理，其实还可以从需求角度去处理。</p><ul><li>数值格式化，格式化成用户好阅读的格式，例如：1 亿、1 百万。</li><li>表单校验，不允许用户输入超过多少位的数值。</li></ul>          </div><h2 id="拓展（大数相加）"><a href="#拓展（大数相加）" class="headerlink" title="拓展（大数相加）"></a>拓展（大数相加）</h2><p>这也是一个经典的问题，给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。</p><p><strong>思路描述：</strong><br>当然可以用上面的两种方式去解决，这里就以笔试题的形式去实现。</p><ul><li>可能存在 2 个字符串长度不一致，需要先补 0 使得 2 个字符串长度一致。</li><li>一位一位相加，再加进位。（小学列竖式的做法）</li></ul><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202412171556092.png" alt="列竖式"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bigNumberAdd</span>(<span class="hljs-params">num1, num2</span>) &#123;<br>  <span class="hljs-comment">// 为了保持2个数长度一直，补0</span><br>  <span class="hljs-keyword">const</span> maxLength = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(num1.<span class="hljs-property">length</span>, num2.<span class="hljs-property">length</span>);<br>  num1 = num1.<span class="hljs-title function_">padStart</span>(maxLength, <span class="hljs-string">&quot;0&quot;</span>);<br>  num2 = num2.<span class="hljs-title function_">padStart</span>(maxLength, <span class="hljs-string">&quot;0&quot;</span>);<br><br>  <span class="hljs-comment">// 是否进一</span><br>  <span class="hljs-keyword">let</span> carry = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 保存最终结果</span><br>  <span class="hljs-keyword">let</span> result = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = maxLength - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>    <span class="hljs-comment">// 每一位相加，如果大于等于10，就进一</span><br>    <span class="hljs-keyword">const</span> temp = <span class="hljs-title class_">Number</span>(num1[i]) + <span class="hljs-title class_">Number</span>(num2[i]) + carry;<br>    carry = temp &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    result = (temp % <span class="hljs-number">10</span>) + result;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (carry) &#123;<br>    result = carry + result;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>延伸：</p><ul><li><a href="https://leetcode.cn/problems/add-strings/description/">leetCode 字符串相加</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录一次前端优化企业项目</title>
    <link href="/project/optimization-project/"/>
    <url>/project/optimization-project/</url>
    
    <content type="html"><![CDATA[<h1 id="记录一次前端优化企业项目"><a href="#记录一次前端优化企业项目" class="headerlink" title="记录一次前端优化企业项目"></a>记录一次前端优化企业项目</h1><p>随着部门项目业务功能越来越多，发现打包速度慢、体积较大，想着能否针对 webpack 做优化。</p><h2 id="优化打包速度"><a href="#优化打包速度" class="headerlink" title="优化打包速度"></a>优化打包速度</h2><p>首先要找一个衡量速度的工具，webpack 插件<code>speed-measure-webpack-plugin</code>，可以测量所有 loader 花费的时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SpeedMeasurePlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;speed-measure-webpack-plugin&quot;</span>);<br><span class="hljs-keyword">const</span> smp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpeedMeasurePlugin</span>();<br><br><span class="hljs-keyword">return</span> smp.<span class="hljs-title function_">wrap</span>(&#123;<br>  <span class="hljs-comment">// webpack文件返回的配置</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>然后执行<code>yarn build</code>，等待一会出结果。<br><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409121657862.png" alt="优化loader前打包结果，总计打包时间287s"></p><p>从图中可以看出，<code>babel-loader、less-loader</code> 执行时间较长，另外还有 <code>eslint-loader</code>，由于平时开发中编辑器都开启了 eslint 功能，另外在代码提交的时候有 <code>pre-commit</code> 也会做检测，由于项目过大每次打包都要让<code>eslint-loader</code>全量检测一遍，属实浪费时间性能，因此可以去掉，另外 2 个 loader 执行时间长，可能匹配内容过多，浪费不必要的搜索。</p><h3 id="优化-loader"><a href="#优化-loader" class="headerlink" title="优化 loader"></a>优化 loader</h3><p>从这两个角度出发，首先去掉<code>eslint-loader</code>，然后优化其他 loader 的匹配规则。</p><p>项目中使用的.less、.js、.jsx，在源码中发现：</p><ul><li>存在不必要的 loader，例如 sass-loader 等项目用不到的类型文件，需要去掉。</li><li>匹配了很多不需要匹配的文件后缀名，所以来说其他 loader 匹配文件都是浪费搜索性能的。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 举例</span><br>&#123;<br>  <span class="hljs-attr">rules</span>: [<br>    &#123;<br>      <span class="hljs-comment">// 发现多出loader，都匹配不必要的文件类型，一并去掉</span><br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(js|jsx)$/</span>, <span class="hljs-comment">// =&gt; 没必要匹配这么多文件, 优化前：(js|mjs|jsx|ts|tsx)，</span><br>      <span class="hljs-attr">loader</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;babel-loader&quot;</span>),<br>    &#125;,<br><br>    <span class="hljs-comment">// 类似这种的，可以去掉，因为项目并没有用到scss类型文件</span><br>    &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(scss|sass)$/</span>,<br>      <span class="hljs-attr">loader</span>: <span class="hljs-built_in">require</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;sass-loader&quot;</span>),<br>    &#125;,<br>  ];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409121657182.png" alt="优化loader后打包结果，打包时间119s"></p><div class="note note-success">            <p>时间从 287s 优化到 119s，速度提升了 58%。</p>          </div><h2 id="优化体积"><a href="#优化体积" class="headerlink" title="优化体积"></a>优化体积</h2><p>首先使用 webpack 插件<code>webpack-bundle-analyzer</code>分析各个包打包后的体积。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;webpack-bundle-analyzer&quot;</span>).<span class="hljs-property">BundleAnalyzerPlugin</span>;<br><br><span class="hljs-comment">// webpack的plugins加入分析插件</span><br>&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>(&#123; <span class="hljs-attr">analyzerPort</span>: <span class="hljs-number">9999</span> &#125;)];<br>&#125;<br></code></pre></td></tr></table></figure><p>打包后发现第三方库<code>moment、echarts、ant design、lodash</code>体积比较大。</p><ul><li>moment 体积大是因为把本地化内容页打包了。</li><li>Echarts 所有图形都打包了，其实只需要打包项目中用到的图的类型。</li><li>ant design 体积过大，由于时间控件内部采用 moment，应该替换成 dayjs。</li><li>lodash 默认打包了所有功能函数。</li></ul><h3 id="优化-moment"><a href="#优化-moment" class="headerlink" title="优化 moment"></a>优化 moment</h3><p>使用<code>IgnorePlugin</code> 忽略指定目录，<code>moment</code>会将所有本地化内容和核心功能一起打包，可以使用这个插件忽略本地化内容，在使用的时候再引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-comment">//忽略 moment 下的 ./locale 目录</span><br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">IgnorePlugin</span>(<span class="hljs-regexp">/^\.\/locale$/</span>, <span class="hljs-regexp">/moment$/</span>),<br>  ];<br>&#125;<br><br><span class="hljs-comment">// 在使用的时候</span><br><span class="hljs-keyword">import</span> moment <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;moment&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;moment/locale/zh-cn&quot;</span>; <span class="hljs-comment">// 手动引入</span><br>moment.<span class="hljs-title function_">locale</span>(<span class="hljs-string">&quot;zh-cn&quot;</span>);<br></code></pre></td></tr></table></figure><p>优化前后差别：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409121653028.png" alt="moment优化前"></div><div class="group-image-wrap"><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409121659611.png" alt="moment优化后"></div></div></div><div class="note note-success">            <p>从图可以看出优化挺大的，264kb 到 60kb，体积减少了 77%。</p>          </div><h3 id="优化-Echarts"><a href="#优化-Echarts" class="headerlink" title="优化 Echarts"></a>优化 Echarts</h3><p>用到什么类型图表，就引入什么类型的，没必要所有一并引入。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 目前采用的是</span><br><span class="hljs-keyword">import</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;echarts&quot;</span>;<br><br><span class="hljs-comment">// 修改后，目前项目用的饼状图，和线图；按需引入</span><br><span class="hljs-keyword">import</span> echarts <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;echarts/lib/echarts&quot;</span>;<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;echarts/lib/component/title&quot;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;echarts/lib/component/tooltip&quot;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;echarts/lib/component/legend&quot;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;echarts/lib/component/grid&quot;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;echarts/lib/chart/pie&quot;</span>);<br><span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;echarts/lib/chart/line&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>优化前</strong>，由图可以看出打包了所有图表类型<br><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409121740952.png" alt="echart优化前"></p><p><strong>优化后</strong><br><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409121747088.png" alt="echart优化后"></p><div class="note note-success">            <p>从 5.35m 优化到 253kb。</p>          </div><h3 id="优化-ant-design"><a href="#优化-ant-design" class="headerlink" title="优化 ant design"></a>优化 ant design</h3><p>在使用 Time-Picker 等时间控件的时候，默认使用的 moment，体积比较大，参考官网可以替换成 days.js。</p><p><a href="https://github.com/ant-design/antd-dayjs-webpack-plugin">官方示例</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AntdDayjsWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;antd-dayjs-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AntdDayjsWebpackPlugin</span>(&#123;<br>      <span class="hljs-attr">preset</span>: <span class="hljs-string">&quot;antdv3&quot;</span>,<br>    &#125;),<br>  ],<br>&#125;;<br><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;dayjs/locale/zh-cn&quot;</span>;<br>dayjs.<span class="hljs-title function_">locale</span>(<span class="hljs-string">&quot;zh-cn&quot;</span>);<br></code></pre></td></tr></table></figure><p>尝试过发现并没有看出 ant design 体积变化差异很大，不过这也是一种优化的方向。</p><h3 id="优化-lodash"><a href="#优化-lodash" class="headerlink" title="优化 lodash"></a>优化 lodash</h3><p>目前采用<code>lodash</code>包，应该需要使用<code>lodash-es</code>模块化版本，支持 tree-shaking，可以减少打包体积。<br>不过目前项目都是用 <code>lodash</code>，并且没有单独使用函数，例如：<code>import cloneDeep from &#39;lodash/cloneDeep&#39;</code>，由于使用地方比较多，也不能每个页面都检查，所以打算采用<code>lodash-webpack-plugin + babel-plugin-lodash</code>两个 webpack 插件。</p><ul><li><code>babel-plugin-lodash</code>可以自动将 lodash 函数按需引入。</li><li><code>webpack-lodash-plugin</code>去掉多余的功能代码，进一步减少体积。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash/fp&quot;</span>;<br><span class="hljs-keyword">const</span> addOne = <span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);<br>_.<span class="hljs-title function_">map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], addOne);<br><br><span class="hljs-comment">// 打包后</span><br><span class="hljs-keyword">import</span> _add <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash/fp/add&quot;</span>;<br><span class="hljs-keyword">import</span> _map <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash/map&quot;</span>;<br><span class="hljs-keyword">const</span> addOne = <span class="hljs-title function_">_add</span>(<span class="hljs-number">1</span>);<br><span class="hljs-title function_">_map</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], addOne);<br></code></pre></td></tr></table></figure><p><strong>配置 webpack</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// webpack.config.js文件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">LodashModuleReplacementPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;lodash-webpack-plugin&quot;</span>);<br><br><span class="hljs-keyword">const</span> webpackConfig = &#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">LodashModuleReplacementPlugin</span>()],<br>&#125;;<br><br><span class="hljs-comment">// .babelrc文件</span><br>&#123;<br>  <span class="hljs-attr">plugins</span>: [[<span class="hljs-string">&quot;lodash&quot;</span>]];<br>&#125;<br></code></pre></td></tr></table></figure><p>优化前后差别：</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409131148025.png" alt="优化前"></div><div class="group-image-wrap"><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409131149057.png" alt="优化后"></div></div></div><div class="note note-success">            <p>lodash 体积从 97kb 优化到 13kb，缩小了 86%的体积。</p>          </div><h2 id="代码打包分块"><a href="#代码打包分块" class="headerlink" title="代码打包分块"></a>代码打包分块</h2><p>使用代码分块之前，涉及到两个知识点：</p><ul><li>代码分离（Code Splitting）：动态加载代码，在需要的时候再来加载，例如路由懒加载。</li><li>打包分离（Bundle Splitting）：主要是为更好的缓存，创建更多、更小的文件，可能很多页面共用了某一个模块功能，将其单独打包出来。</li></ul><div class="note note-secondary">            <p>分包之前要考虑为什么要分包，能给项目带来什么优势？</p><ul><li>代码分离：如果不用路由懒加载，那就是一开始进入页面就会加载所有业务模块，导致首屏渲染速度很慢。</li><li>打包分离：如果有一个体积很大的文件，只改了少量的代码，浏览器仍然要重新下载整个文件，如果分为两个或多个文件，浏览器只需要下载改动那个文件，其他未改动的部分从浏览器缓存中加载，可以提高加载速度。（所以来说代码分割提高访问速度，是与浏览器缓存息息相关。）</li></ul>          </div><p><strong>整体思路：</strong>需要怎么拆分，需要把不是每次都用到的依赖拆分出来，让其在使用的时候再根据页面按需加载。只有一个目的，就是要把用的比较少的公共依赖文件分割出来；引用次数较多的模块分割出来，避免每次都要重新加载那一部分代码。</p><p>着手操作：</p><ul><li>将项目框架代码分割，基本每个页面都会用到，例如：React、Ract-dom、React-dom-router、React-redux 等。</li><li>将 Echarts 分割，目前了解到只有几个页面使用了图表，只需要访问指定页面再按需加载即可。</li><li>项目中业务组件，基本都会用到，也需要单独分割出来。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimize</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">splitChunks</span>: &#123;<br>      <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;all&quot;</span>,<br>      <span class="hljs-comment">//all: 不管文件是动态还是非动态载入，统一将文件分离。当页面首次载入会引入所有的包</span><br>      <span class="hljs-comment">//async： 将异步加载的文件分离，首次一般不引入，到需要异步引入的组件才会引入。</span><br>      <span class="hljs-comment">//initial：将异步和非异步的文件分离，如果一个文件被异步引入也被非异步引入，那它会被打包两次（注意和all区别），用于分离页面首次需要加载的包。</span><br><br>      <span class="hljs-attr">minSize</span>: <span class="hljs-number">30000</span>, <span class="hljs-comment">// 文件最小打包体积</span><br>      <span class="hljs-attr">minChunks</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 文件最少引入次数，引入2次以上就会被打包</span><br><br>      <span class="hljs-comment">// 这里面打包配置，优先级高于外面的</span><br>      <span class="hljs-attr">cacheGroups</span>: &#123;<br>        <span class="hljs-comment">// 项目框架, 一开始就引入所有，因此使用all</span><br>        <span class="hljs-attr">vendors</span>: &#123;<br>          <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;all&quot;</span>,<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/(react|react-dom|react-dom-router|react-redux|公司内部框架)/</span>,<br>          <span class="hljs-attr">priority</span>: <span class="hljs-number">100</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;vendors&quot;</span>,<br>        &#125;,<br>        <span class="hljs-comment">// echarts只有部分页面使用，需要按需加载，因此需要用async</span><br>        <span class="hljs-attr">echartsVendors</span>: &#123;<br>          <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;async&quot;</span>,<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/echarts/</span>,<br>          <span class="hljs-attr">priority</span>: <span class="hljs-number">100</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;echartsVendors&quot;</span>,<br>        &#125;,<br>        <span class="hljs-comment">// 其他业务组件</span><br>        <span class="hljs-attr">commons</span>: &#123;<br>          <span class="hljs-attr">chunks</span>: <span class="hljs-string">&quot;all&quot;</span>,<br>          <span class="hljs-attr">test</span>: <span class="hljs-regexp">/(ta-biz|yss-biz)/</span>,<br>          <span class="hljs-attr">minChunks</span>: <span class="hljs-number">2</span>,<br>          <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;commmon&quot;</span>,<br>          <span class="hljs-attr">priority</span>: <span class="hljs-number">90</span>,<br>        &#125;,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>打包分割是和浏览器的缓存机制存在联系的，主要是通过浏览器缓存没有变化的资源，提高加载速度。</li><li>开发代码中尽量少用<code>import * from &#39;xxx&#39;</code>，没法进行 tree-shaking，导致打包体积变大。</li><li>对于时间的处理，尽量使用体积更小的 dayjs，而不是体积较大的 moment，如果必须要使用 moment，一定要对本地化配置做处理，减少打包体积。</li><li>对于<code>lodash</code>，尽量使用模块版本的<code>lodash-es</code>，可以利用 tree-shaking，减少打包体积。</li></ul>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redux原理分析</title>
    <link href="/react/redux-theory/"/>
    <url>/react/redux-theory/</url>
    
    <content type="html"><![CDATA[<h1 id="Redux-原理分析"><a href="#Redux-原理分析" class="headerlink" title="Redux 原理分析"></a>Redux 原理分析</h1><p>Redux 是一个管理全局应用状态的库，redux 可以理解为是一个上帝视角，包含了应用所需要的东西，发放给需要的组件，redux 更新了也会去通知对应的组件。</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409091952570.png"></p><h2 id="回顾-redux-的使用"><a href="#回顾-redux-的使用" class="headerlink" title="回顾 redux 的使用"></a>回顾 redux 的使用</h2><p>学习原理之前，肯定需要熟练的应用，这样才能更好的理解原理。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 创建修改store的纯函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">xxReducer</span>(<span class="hljs-params">state = &#123; name: <span class="hljs-string">&quot;chenjiang&quot;</span> &#125;, action</span>) &#123;<br>  <span class="hljs-keyword">switch</span> (action.<span class="hljs-property">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;add&quot;</span>:<br>      <span class="hljs-comment">// todo</span><br>      <span class="hljs-keyword">return</span> state;<br>    ...<br>    <span class="hljs-attr">default</span>:<br>      <span class="hljs-keyword">return</span> state;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建Store</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(xxReducer);<br><br><span class="hljs-comment">// 组件内触发更新操作</span><br>store.<span class="hljs-title function_">dispatch</span>(&#123;<span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;add&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p>几大核心概念：</p><p><strong>Store</strong>：正如其名“仓库”，它存储了所有的状态，并且提供操作它的 API。<br><strong>Action</strong>：触发一个动作，告诉 redux，我将要处理什么逻辑，但是真正的逻辑并不是它去做，而是交给 reducer。<br><strong>Reducder</strong>：接收到 Action 指令，找到对应的处理逻辑，处理完成后更新 Store 状态。</p><p>以下对原理剖析。</p><h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><p>redux 版本：v5.0.1</p><p>先从<code>createStore</code>入口出发，我们简化一下源码，大致结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">reducer, preloadedState, enhancer</span>) &#123;<br>  <span class="hljs-comment">// 可以看出enhancer“增强器”，本质是一个高阶函数，传进去一些功能方法，最后返回一个更强大的store，有点类似高阶组件</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> enhancer !== <span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">enhancer</span>(createStore)(reducer, preloadedState);<br>  &#125;<br>  <span class="hljs-keyword">let</span> currentReducer = reducer;<br>  <span class="hljs-keyword">let</span> currentState = preloadedState;<br>  <span class="hljs-keyword">let</span> currentListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>  <span class="hljs-keyword">let</span> nextListeners = currentListeners;<br>  <span class="hljs-keyword">let</span> listenerIdCounter = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureCanMutateNextListeners</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener</span>) &#123;&#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">action</span>) &#123;&#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceReducer</span>(<span class="hljs-params">nextReducer</span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 初始化: 触发一个动作，默认更新一次</span><br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">INIT</span> &#125;);<br><br>  <span class="hljs-keyword">const</span> store = &#123;<br>    <span class="hljs-attr">dispatch</span>: dispatch,<br>    subscribe,<br>    getState,<br>    replaceReducer,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> store;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ensureCanMutateNextListeners-拷贝一份监听器数组"><a href="#ensureCanMutateNextListeners-拷贝一份监听器数组" class="headerlink" title="ensureCanMutateNextListeners 拷贝一份监听器数组"></a>ensureCanMutateNextListeners 拷贝一份监听器数组</h3><p>主要作用是防止监听器数组被错误修改，函数逻辑其实很简单，就是把当前<code>currentListeners</code>监听器数组拷贝一份给<code>nextListeners</code>。</p><div class="note note-warning">            <p>不经有疑问为什么要多此一举呢？主要是和 Redux 订阅和通知的机制有关系。</p><p>当我们调用 dispatch ，如果此时又调用 subscribe、unsubscribe，那么就会有意外问题，比如：</p><ul><li>在 dispatch 后，redux 会遍历监听器数组，调用监听器过程中也存在添加或者移除监听器的操作，可能本次 dispatch 中遗漏了一些监听器的调用。</li><li>如果在多个地方使用同一个监听器数组的引用，对数组的修改会影响到其它地方。因此最好确保是一个独立的副本，以避免不必要的副作用。</li></ul>          </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 没拷贝之前，两者的引用地址是一样的</span><br><span class="hljs-comment">// 因为初始化调用createStore时候  let nextListeners = currentListeners;</span><br><br><span class="hljs-comment">// 版本4.xx中</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureCanMutateNextListeners</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (nextListeners === currentListeners) &#123;<br>    nextListeners = currentListeners.<span class="hljs-title function_">slice</span>(); <span class="hljs-comment">// 浅拷贝</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 版本5.0.1</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ensureCanMutateNextListeners</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (nextListeners === currentListeners) &#123;<br>    nextListeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();<br>    currentListeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">listener, key</span>) =&gt;</span> &#123;<br>      nextListeners.<span class="hljs-title function_">set</span>(key, listener);<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>版本 5 以后为什么采用 Map 没有用原来的 slice？</p><p>因为 Map 的好处它允许我们更方便的添加、删除、以及查找监听器，并且性能比直接操作数据更高效。Map 的查找和删除操作时间复杂度是 O(1)，而数组的查找和删除操作是 O(n);</p><h3 id="getState-获取最新的状态"><a href="#getState-获取最新的状态" class="headerlink" title="getState 获取最新的状态"></a>getState 获取最新的状态</h3><p>返回最新的状态</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getState</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> currentState;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="subscribe-订阅回调"><a href="#subscribe-订阅回调" class="headerlink" title="subscribe 订阅回调"></a>subscribe 订阅回调</h3><p>调用订阅函数，返回一个取消订阅函数，形成闭包，那么<code>isSubscribed</code>就一直被保留，如果重复订阅，也就会被阻止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener</span>) &#123;<br>  <span class="hljs-keyword">let</span> isSubscribed = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标识当前回调已经被订阅了</span><br>  <span class="hljs-title function_">ensureCanMutateNextListeners</span>(); <span class="hljs-comment">// 拷贝订阅者数组（map）</span><br>  <span class="hljs-keyword">const</span> listenerId = listenerIdCounter++;<br>  nextListeners.<span class="hljs-title function_">set</span>(listenerId, listener); <span class="hljs-comment">// 加入新的订阅者</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">unsubscribe</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (!isSubscribed) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    isSubscribed = <span class="hljs-literal">false</span>;<br>    <span class="hljs-title function_">ensureCanMutateNextListeners</span>();<br>    nextListeners.<span class="hljs-title function_">delete</span>(listenerId); <span class="hljs-comment">// 移除订阅者</span><br>    currentListeners = <span class="hljs-literal">null</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="dispatch-触发更新指令"><a href="#dispatch-触发更新指令" class="headerlink" title="dispatch 触发更新指令"></a>dispatch 触发更新指令</h3><p>接收更新指令，交给 reducer，reducer 处理完成后，通知所有订阅者。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">action</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    isDispatching = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 把触发更新指令交给reducer，render才是真正处理更新逻辑的</span><br>    currentState = <span class="hljs-title function_">currentReducer</span>(currentState, action);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    isDispatching = <span class="hljs-literal">false</span>;<br>  &#125;<br>  <span class="hljs-keyword">const</span> listeners = (currentListeners = nextListeners);<br>  <span class="hljs-comment">// 通知所有订阅者</span><br>  listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">listener</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">listener</span>();<br>  &#125;);<br>  <span class="hljs-keyword">return</span> action;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="replaceReducer-动态替换-reducer"><a href="#replaceReducer-动态替换-reducer" class="headerlink" title="replaceReducer 动态替换 reducer"></a>replaceReducer 动态替换 reducer</h3><p>在运行时动态替换 store 中的 reducer</p><div class="note note-secondary">            <p>应用场景：</p><ul><li>例如不同角色，处理同一个功能，存在不同的处理逻辑，此时就需要根据登录的用户来切换 reducer 来处理不同的逻辑。</li><li>动态加载 reducer：为了优化性能和加载时间，常常会将 reducer 按需加载，在需要的时候再来加载。</li></ul>          </div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceReducer</span>(<span class="hljs-params">nextReducer</span>) &#123;<br>  currentReducer = nextReducer;<br>  <span class="hljs-title function_">dispatch</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-title class_">ActionTypes</span>.<span class="hljs-property">REPLACE</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="combineReducers-合并多个-reducer"><a href="#combineReducers-合并多个-reducer" class="headerlink" title="combineReducers 合并多个 reducer"></a>combineReducers 合并多个 reducer</h2><p>在整个应用中，不同的模块会有不同的处理逻辑，因此需要拆分成多个 reducer 来处理独立逻辑，但是 createStore 只能传入一个 reducer，这时就需要传之前将多个 reducer 合并。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 使用combineReducers</span><br><span class="hljs-keyword">const</span> rootReducer = <span class="hljs-title function_">combineReducers</span>(&#123;<br>  <span class="hljs-attr">login</span>: loginReducer,<br>  <span class="hljs-attr">home</span>: homeReducer,<br>&#125;);<br><span class="hljs-title function_">createStore</span>(rootReducer);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">combineReducers</span>(<span class="hljs-params">reducers</span>) &#123;<br>  <span class="hljs-comment">// 获取所有reducer的key</span><br>  <span class="hljs-keyword">const</span> reducerKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers);<br><br>  <span class="hljs-keyword">const</span> finalReducers = &#123;&#125;;<br>  <span class="hljs-comment">// 从用户提供的reducer集合拷贝一份，主要是过滤掉不是函数的reducer</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; reducerKeys.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> key = reducerKeys[i];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> reducers[key] === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>      finalReducers[key] = reducers[key];<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 拿到最终所有符合要求的reducer的key</span><br>  <span class="hljs-keyword">const</span> finalReducerKeys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(finalReducers);<br><br>  <span class="hljs-comment">// 最终返回的是一个函数，那我们每次使用reducer时候，其实就是执行这个函数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">combination</span>(<span class="hljs-params">state = &#123;&#125;, action</span>) &#123;<br>    <span class="hljs-keyword">let</span> hasChanged = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">const</span> nextState = &#123;&#125;;<br>    <span class="hljs-comment">// 遍历所有reducer</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; finalReducerKeys.<span class="hljs-property">length</span>; i++) &#123;<br>      <span class="hljs-keyword">const</span> key = finalReducerKeys[i];<br>      <span class="hljs-comment">// 获取每一个reducer</span><br>      <span class="hljs-keyword">const</span> reducer = finalReducers[key];<br>      <span class="hljs-comment">// 旧的state状态</span><br>      <span class="hljs-keyword">const</span> previousStateForKey = state[key];<br>      <span class="hljs-comment">// 执行reducer过后返回新的state状态</span><br>      <span class="hljs-keyword">const</span> nextStateForKey = <span class="hljs-title function_">reducer</span>(previousStateForKey, action);<br><br>      <span class="hljs-comment">// 将此reducer处理后的最新状态保存到map中</span><br>      nextState[key] = nextStateForKey;<br>      <span class="hljs-comment">// 判断前后是否存在变化，也就是执行前后state引用有没有发生改变</span><br>      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;<br>    &#125;<br><br>    <span class="hljs-comment">// 验证state和reudcer的数量是否匹配，要确保每个state都有reducer处理</span><br>    <span class="hljs-comment">// 之前提到过有个replaceReducer可以动态处理reducer，</span><br>    <span class="hljs-comment">// 可能在某个时间点，动态的添加或者删除reducer，如果有不匹配的情况就需要给出提示。</span><br>    hasChanged = hasChanged || finalReducerKeys.<span class="hljs-property">length</span> !== <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(state).<span class="hljs-property">length</span>;<br><br>    <span class="hljs-keyword">return</span> hasChanged ? nextState : state;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="applyMiddleware-使用中间件"><a href="#applyMiddleware-使用中间件" class="headerlink" title="applyMiddleware 使用中间件"></a>applyMiddleware 使用中间件</h2><p>这个 API 主要是为了接入 Redux 生态，例如接入 redux-logger、redux-thunk 等，通俗来讲这个函数是 redux 功能的加强器（<code>enhancer</code>）。</p><p>整体剖析这个<code>applyMiddleware</code>，调用<code>applyMiddleware</code>返回一个函数（可以理解为加强功能的函数），我们在 createStore 源码中可以看到这一行<code>enhancer(createStore)(reducer, preloadedState)</code>，<code>enhancer(createStore)</code>就可以理解为加强 createStore 功能，返回一个加强后的 createStore（Plus 版本），再次调用就等同于 <code>createStorePlus(reducer, preloadedState)</code>。</p><p>下面再来看看细节，它是如何加强的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 看看如何使用</span><br><span class="hljs-title function_">createStore</span>(rootReducer, <span class="hljs-title function_">applyMiddleware</span>(thunkMiddleware, loggerMiddleware));<br><br><span class="hljs-comment">// applyMiddleware源码</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">...middlewares</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">createStore</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">reducer, preloadedState</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 一开始调用原版的createStore</span><br>    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(reducer, preloadedState);<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">dispatch</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br>    <span class="hljs-keyword">const</span> middlewareAPI = &#123;<br>      <span class="hljs-attr">getState</span>: store.<span class="hljs-property">getState</span>,<br>      <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">action, ...args</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(action, ...args),<br>    &#125;;<br><br>    <span class="hljs-comment">// 将getState和dispatch两个函数传给中间件函数使用</span><br>    <span class="hljs-keyword">const</span> chain = middlewares.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">middleware</span>) =&gt;</span> <span class="hljs-title function_">middleware</span>(middlewareAPI));<br><br>    <span class="hljs-comment">// 替换dispatch函数为加强版的dispatch</span><br>    dispatch = <span class="hljs-title function_">compose</span>(...chain)(store.<span class="hljs-property">dispatch</span>);<br>    <span class="hljs-keyword">return</span> &#123;<br>      ...store,<br>      dispatch,<br>    &#125;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>有和没有 compose 处理，有什么不同呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">applyMiddleware</span>(thunkMiddleware, loggerMiddleware);<br><br><span class="hljs-comment">// 没有compose处理</span><br><span class="hljs-comment">// 先执行loggerMiddleware，然后再来执行thunkMiddleware，两者并没有联系</span><br><span class="hljs-title function_">loggerMiddleware</span>();<br><span class="hljs-title function_">thunkMiddleware</span>();<br><br><span class="hljs-comment">// 有compose处理，上一个执行结果，作为下一个执行的参数（初始化值），这样多个中间件就存在联系。</span><br><span class="hljs-comment">// 类似管道，前面处理完了，后面在前面处理的结果基础上再接着处理。</span><br><span class="hljs-title function_">thunkMiddleware</span>(<span class="hljs-title function_">loggerMiddleware</span>());<br></code></pre></td></tr></table></figure><h3 id="compose-将多个-middleware-产生联系"><a href="#compose-将多个-middleware-产生联系" class="headerlink" title="compose 将多个 middleware 产生联系"></a>compose 将多个 middleware 产生联系</h3><p>也就是上面提到，前面中间的中间件执行结果，最为后面中间件的执行基础.</p><p>先来分析，我们需要什么的结果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn1</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn2</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">2</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn3</span> = (<span class="hljs-params">n</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">3</span>;<br>&#125;;<br><br><span class="hljs-comment">// 我们想要的样子, fn3的执行结果作为fn2的初始值，fn2的执行结果作为fn1的初始值，这样就产生联系。</span><br><span class="hljs-keyword">const</span> total = <span class="hljs-title function_">fn1</span>(<span class="hljs-title function_">fn2</span>(<span class="hljs-title function_">fn3</span>(num)));<br><br><span class="hljs-comment">// 我们需要一个函数来处理</span><br><span class="hljs-keyword">const</span> total1 = <span class="hljs-title function_">compose</span>(fn1, fn2, fn3)(num);<br></code></pre></td></tr></table></figure><p><strong>compose 内部是如何处理的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">...funcs</span>) &#123;<br>  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// infer the argument type so it is usable in inference down the line</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> arg;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (funcs.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> funcs[<span class="hljs-number">0</span>];<br>  &#125;<br><br>  <span class="hljs-comment">// reduce这个函数，回调函数有2个参数，第一个参数是上一次回调返回的结果</span><br>  <span class="hljs-comment">// 从逻辑来看，函数是从右往左执行的，前一次的执行结果，作为下一次参数</span><br>  <span class="hljs-keyword">return</span> funcs.<span class="hljs-title function_">reduce</span>(<br>    <span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span><br>      <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span><br>        <span class="hljs-title function_">a</span>(<span class="hljs-title function_">b</span>(...args))<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Redux 就是一个发布订阅模式，有数据更新了就通知所有订阅者。</li><li>dispatch 并不是真正的去处理逻辑，而是触发更新指令，然后交给 reducer 去处理逻辑。</li><li>applyMiddleware 返回的是一个加强器，类似装饰器模式，调用加强器传入 createStore，返回一个加强版 createStore，也返回了一个提供了一个加强版 dispatch 函数。</li><li>遍历监听器数组，执行回调时候也有可能发生订阅或者取消订阅，这也就是源码换种频繁使用<code>ensureCanMutateNextListeners</code>保证所有订阅者都能收到消息。</li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS实现div拉伸</title>
    <link href="/css/css-resize/"/>
    <url>/css/css-resize/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-实现-div-拉伸"><a href="#CSS-实现-div-拉伸" class="headerlink" title="CSS 实现 div 拉伸"></a>CSS 实现 div 拉伸</h1><p>背景：目前页面左侧是 tree，由于 treeNode 的 title 名称太长，都用省略号展示，产品要求可以通过鼠标调整左侧宽度，以达到可以看全 title。</p><p>效果图大致如下：<br><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409091746146.gif" alt="纯CSS实现div拉伸"></p><h2 id="2-个核心点"><a href="#2-个核心点" class="headerlink" title="2 个核心点"></a>2 个核心点</h2><p><strong>div 宽度需要自适应</strong><br>width 默认情况下, 块级元素不设置宽度, 默认为整个屏幕宽度或者和父级同宽，如果元素脱离了文档流(浮动或者定位), 那么元素的宽度由元素的内容决定</p><p><strong>添加 css resize 属性</strong><br>允许元素可以拉伸，生效条件：不支持内联元素; 块级元素，需要 overflow 属性的计算值不是 visible。</p><h2 id="demo-拉伸图标的展示"><a href="#demo-拉伸图标的展示" class="headerlink" title="demo 拉伸图标的展示"></a>demo 拉伸图标的展示</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.content</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">resize</span>: horizontal;<br>  <span class="hljs-attribute">cursor</span>: ew-resize;<br>  <span class="hljs-attribute">overflow</span>: hidden; // 必须要配合<span class="hljs-attribute">overflow</span>来使用<span class="hljs-attribute">resize</span>, 否则拉伸图标无法显示<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>&#125;<br><br>&lt;<span class="hljs-selector-tag">div</span> class=&quot;<span class="hljs-attribute">content</span>&quot;&gt;<span class="hljs-attribute">content</span>&lt;/<span class="hljs-selector-tag">div</span>&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409091755895.png" alt="实现拉伸图标"></p><div class="note note-warning">            <p>如果需要控制最大或者最小宽度、高度可以通过设置 min-width、min-height、max-width 和 max-height 来限制。</p>          </div><h2 id="DOM-结构设计"><a href="#DOM-结构设计" class="headerlink" title="DOM 结构设计"></a>DOM 结构设计</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- resizable 用于拉伸的工具 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;resizable&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- content 要展示的内容区域 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>content<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><div class="note note-primary">            <ul><li>container 父容器, 用于控制脱离文档流, 然其宽度随着拉伸大小而决定</li><li>resizable 可以拉伸的容器, 从而可以控制父容器的宽度</li><li>content 真正展示的容器, 其宽度随着父级而定</li></ul>          </div>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-e064c6af" role="button" aria-expanded="false" aria-controls="collapse-e064c6af">        <div class="fold-arrow">▶</div>所有代码      </div>      <div class="fold-collapse collapse" id="collapse-e064c6af">        <div class="fold-content">          <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">      <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">        <span class="hljs-comment">/* 脱离文档流 */</span></span><br><span class="language-css">        <span class="hljs-attribute">float</span>: left;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/*  */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.resizable</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">overflow</span>: scroll;</span><br><span class="language-css">        <span class="hljs-attribute">resize</span>: horizontal;</span><br><span class="language-css">        <span class="hljs-attribute">cursor</span>: ew-resize;</span><br><span class="language-css">        <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">min-width</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 盒子宽度最小为200px */</span></span><br><span class="language-css">      &#125;</span><br><span class="language-css">      <span class="hljs-comment">/* 更改拖拽图标的大小和父容器一样大 */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.resizable</span>::-webkit-scrollbar &#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">      &#125;</span><br><span class="language-css"></span><br><span class="language-css">      <span class="hljs-comment">/* 使用定位, 将容器定位到父容器的正中间, 跟着父容器的大小改变而改变 */</span></span><br><span class="language-css">      <span class="hljs-selector-class">.content</span> &#123;</span><br><span class="language-css">        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-comment">/* 留出5px为了鼠标放上去可以显示拖拽 */</span></span><br><span class="language-css">        <span class="hljs-attribute">right</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;</span><br><span class="language-css">      &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- resizable 用于拖拽的工具 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;resizable&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- content 要展示的内容区域 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>content<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>CSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>业务功能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初步了解轻量高效的React状态库Jotai</title>
    <link href="/react/use-jotai/"/>
    <url>/react/use-jotai/</url>
    
    <content type="html"><![CDATA[<h1 id="初步了解轻量高效的-React-状态库-Jotai"><a href="#初步了解轻量高效的-React-状态库-Jotai" class="headerlink" title="初步了解轻量高效的 React 状态库 Jotai"></a>初步了解轻量高效的 React 状态库 Jotai</h1><h2 id="Jotai-是什么"><a href="#Jotai-是什么" class="headerlink" title="Jotai 是什么"></a>Jotai 是什么</h2><p>Jotai 是状态管理库，原子化思想，提供一个最基础的原子，通过组合原子来构建状态，并且基于原子依懒性进行优化渲染，避免了 React 额外的渲染。Atom 在 Jotai 中是状态单位（原子），可以更新也可以被组件订阅（使用<code>useAtom</code>），当 Atom 更新了，那么订阅这个 Atom 的组件便会重新渲染。</p><ul><li>创建原子过程就和使用 useState Hook 一样简单方便，并且全局可用的。<code>const nameAtom = atom(&#39;chenjiang&#39;)</code>。</li><li>使用灵活：可以基于这个或者一些原子，从而衍生出更多状态。</li></ul><h2 id="Jotai-适用场景"><a href="#Jotai-适用场景" class="headerlink" title="Jotai 适用场景"></a>Jotai 适用场景</h2><ul><li><p><strong>中小型项目</strong>：Jotai 设计的目标就是轻量且易用，适合中小型项目，不需要复杂的状态管理。</p></li><li><p><strong>需要局部状态管理</strong>：Jotai 采用原子状态概念，意味着可以将状态拆解为独立的、可组合的原子单元。不需要全局状态管理库的复杂性。</p></li><li><p><strong>组件间的状态传递</strong>：Jotai 可以让多个组件共享相同的原子状态，并且支持同步更新和跨组件传递状态。可以减少 Context 或者 Props 传递过程的繁琐及产生不必要的渲染。</p></li><li><p><strong>高效的异步操作</strong>：Jotai 支持异步操作，使用 <code>atom</code> 配合异步函数，可以优雅的管理数据状态。</p></li><li><p><strong>替代 Context 或 Redux</strong>：Jotai 是一个更加简洁的状态管理工具，可以替代复杂的 Context 和 Redux，尤其当项目不需要全局状态或者深层的状态管理时。</p></li><li><p><strong>开发者希望拥有更细粒度控制场景</strong>：Jotai 的原子状态机制允许你精确的控制每个状态更新和影响范围。相比传统的 Redux，没有过多的样板代码，提供了更高的灵活性。</p></li><li><p><strong>需要状态持久化</strong>：Jotai 提供 API 可以与<code>localStorage</code>和<code>sessionStorage</code>配合，支持状态持久化到客户端。<br>s</p></li></ul><h2 id="Jotai-设计理念"><a href="#Jotai-设计理念" class="headerlink" title="Jotai 设计理念"></a>Jotai 设计理念</h2><ul><li><p><strong>原子化</strong>：将状态拆分为小的、独立的单元，Jotai 是状态变的更加准确，从而提高了性能和可维护性。每个组件只会重新渲染它所依赖的原子，而不是整个应用。</p></li><li><p><strong>React 原生集成</strong>：不需要引入复杂的方法，直接能够与 React 现有的功能集成。学习曲线低，避免了传统的状态管理库的复杂配置和样板代码，更容易上手。</p></li><li><p><strong>细粒度的状态管理</strong>：状态细分为多个小的原子，每个原子代表一个特定的、独立的状态单元，开发者可以灵活的组合和管理这些原子。通过这种状态管理，Jotai 能够更加精确的控制，每个原子的更新只会影响那些依赖它的组件，避免了不必要的渲染，从而提高应用性能。</p></li><li><p><strong>更好的异步操作</strong>：Jotai 支持异步原子的创建，可以将异步操作集成到原子中。不需要再为异步操作编写额外的逻辑或者使用特殊的中间件（例如：Redux Thunk），只需要将异步操作封装为原子即可。</p></li></ul><h2 id="初步体验原子状态"><a href="#初步体验原子状态" class="headerlink" title="初步体验原子状态"></a>初步体验原子状态</h2><p>和 useState 类似，useAtom 会返回一个最新的原子状态和修改原子状态的方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; atom, useAtom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./App.css&quot;</span>;<br><br><span class="hljs-keyword">const</span> nameAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-string">&quot;chenjiang&quot;</span>); <span class="hljs-comment">// 创建一个原子</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useAtom</span>(nameAtom); <span class="hljs-comment">// 使用原子或者说App组件订阅了这个原子</span><br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(name + &quot;123&quot;); // 更新原子的值</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改name</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h2 id="原子可组合性（基于原子衍生出更多状态）"><a href="#原子可组合性（基于原子衍生出更多状态）" class="headerlink" title="原子可组合性（基于原子衍生出更多状态）"></a>原子可组合性（基于原子衍生出更多状态）</h2><p>某个原子依赖另外一个原子，当依赖的原子更新了，那么当前的原子也随之更新。<br>例如：name 大写这个 atom 它本身依赖 name，当最基础的 name 发生了变化，name 大写也会更新，订阅此原子的组件也重新渲染。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> nameAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-string">&quot;chenjiang&quot;</span>);<br><br><span class="hljs-keyword">const</span> nameUppercaseAtom = <span class="hljs-title function_">atom</span>(<span class="hljs-function">(<span class="hljs-params">get</span>) =&gt;</span> <span class="hljs-title function_">get</span>(nameAtom).<span class="hljs-title function_">toUpperCase</span>());<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Uppercase</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [uppercaseName] = <span class="hljs-title function_">useAtom</span>(nameUppercaseAtom);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;uppercaseName&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useAtom</span>(nameAtom);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(name + &quot;666&quot;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改name</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Uppercase</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="状态持久化"><a href="#状态持久化" class="headerlink" title="状态持久化"></a>状态持久化</h2><p>一般来说页面刷新后，所有的状态都丢失，都恢复成初始值。Jotai 提供了一个工具方法<code>atomWithStorage </code>，保留原子状态到 localStorage（默认）。</p><h3 id="localstorage"><a href="#localstorage" class="headerlink" title="localstorage"></a>localstorage</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useAtom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; atomWithStorage &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai/utils&quot;</span>;<br><br><span class="hljs-keyword">const</span> nameAtom = <span class="hljs-title function_">atomWithStorage</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;chenjiang&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useAtom</span>(nameAtom);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(name + &quot;666&quot;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改name</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义存储</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> sessionStorageAtom = <span class="hljs-title function_">atomWithStorage</span>(<br>  <span class="hljs-string">&quot;sessionKey&quot;</span>, <span class="hljs-comment">// 存储键名</span><br>  <span class="hljs-string">&quot;defaultValue&quot;</span>, <span class="hljs-comment">// 默认值</span><br>  &#123;<br>    <span class="hljs-attr">getItem</span>: <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;&#125;, <span class="hljs-comment">// 自定义的 get 方法</span><br>    <span class="hljs-attr">setItem</span>: <span class="hljs-function">(<span class="hljs-params">key, value</span>) =&gt;</span> &#123;&#125;, <span class="hljs-comment">// 自定义的 set 方法</span><br>    <span class="hljs-attr">removeItem</span>: <span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> &#123;&#125;, <span class="hljs-comment">// 自定义的 remove 方法</span><br>  &#125;<br>);<br></code></pre></td></tr></table></figure><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useAtom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; atomWithStorage, createJSONStorage &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai/utils&quot;</span>;<br><br><span class="hljs-keyword">const</span> storage = <span class="hljs-title function_">createJSONStorage</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">sessionStorage</span>);<br><span class="hljs-keyword">const</span> nameAtom = <span class="hljs-title function_">atomWithStorage</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;chenjiang&quot;</span>, storage);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useAtom</span>(nameAtom);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(name + &quot;666&quot;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改name</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可复原的原子状态"><a href="#可复原的原子状态" class="headerlink" title="可复原的原子状态"></a>可复原的原子状态</h2><p>通过<code>atomWithReset</code>定义可还原原子，再通过<code>useResetAtom</code>hook 创建一个可还原的方法。<br>类似表单的重置功能，对原子进行一系列更新之后复原，回到最初始状态。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useAtom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; atomWithReset, useResetAtom &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;jotai/utils&quot;</span>;<br><br><span class="hljs-keyword">const</span> nameAtom = <span class="hljs-title function_">atomWithReset</span>(<span class="hljs-string">&quot;chenjiang&quot;</span>);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [name, setName] = <span class="hljs-title function_">useAtom</span>(nameAtom); <span class="hljs-comment">// 使用原子</span><br>  <span class="hljs-keyword">const</span> resetName = <span class="hljs-title function_">useResetAtom</span>(nameAtom); <span class="hljs-comment">// 重置原子</span><br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setName(name + &quot;666&quot;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改name</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;resetName&#125;</span>&gt;</span>复原<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>&#123;name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typescript知识点</title>
    <link href="/ts/technology/"/>
    <url>/ts/technology/</url>
    
    <content type="html"><![CDATA[<h1 id="Typescript-中-interface-和-type-区别"><a href="#Typescript-中-interface-和-type-区别" class="headerlink" title="Typescript 中 interface 和 type 区别"></a>Typescript 中 interface 和 type 区别</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><p><strong>都可以描述对象或者数组</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">SetUser</span> &#123;<br>  (<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>) =&gt; <span class="hljs-built_in">void</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;;<br><span class="hljs-keyword">type</span> setUser = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br></code></pre></td></tr></table></figure><p><strong>都允许扩展</strong><br>inteface 和 type 都可以拓展，并且可以相互扩展。</p><p><strong>各自扩展</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Name</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Name</span> &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-comment">// ==================================</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = <span class="hljs-title class_">Name</span> &amp; &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125;;<br></code></pre></td></tr></table></figure><p><strong>相互扩展</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Name</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span> &#125; &amp; <span class="hljs-title class_">Name</span>;<br><br><span class="hljs-comment">// ==================================</span><br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Name</span> &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><p><strong>type 可以的，interface 不可以</strong></p><p>type 可以声明类型别名、联合类型、元组等类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 声明类型别名</span><br><span class="hljs-keyword">type</span> cxkyyds = <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 以后就可以用cxkyyds来表示字符串类型</span><br><br><span class="hljs-comment">// 联合类型</span><br><span class="hljs-keyword">type</span> action = <span class="hljs-string">&quot;ADD&quot;</span> | <span class="hljs-string">&quot;EDIT&quot;</span> | <span class="hljs-string">&quot;COPY&quot;</span>;<br><br><span class="hljs-comment">// 定义元组类型，指定数组每个位置元素的类型</span><br><span class="hljs-keyword">type</span> list = [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">boolean</span>];<br></code></pre></td></tr></table></figure><p><strong>interface 可以的，type 不可以</strong><br>interface 可以声明合并，两个同名的 interface 会自动合并</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>: <span class="hljs-title class_">User</span> = &#123;&#125;; <span class="hljs-comment">// Type &#x27;&#123;&#125;&#x27; is missing the following properties from type &#x27;User&#x27;: name, age</span><br><br><span class="hljs-comment">// ==================================</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = &#123; <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;; <span class="hljs-comment">// 报错：Duplicate identifier &#x27;User&#x27;.</span><br></code></pre></td></tr></table></figure><h1 id="TypeScript-中-any、never、unknown、null-undefined-和-void-有什么区别"><a href="#TypeScript-中-any、never、unknown、null-undefined-和-void-有什么区别" class="headerlink" title="TypeScript 中 any、never、unknown、null &amp; undefined 和 void 有什么区别"></a>TypeScript 中 any、never、unknown、null &amp; undefined 和 void 有什么区别</h1><h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><ul><li>含义：any 类型表示任何 JavaScript 值都可以赋值给它，可以绕过 TS 的静态检查。</li><li>应用场景：不想给变量设置类型，或者迁移老的 JavaScript 项目临时使用。</li></ul><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">info</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&quot;chenjiang&quot;</span>;<br>info = <span class="hljs-number">26</span>;<br>info = <span class="hljs-string">&quot;男&quot;</span>;<br></code></pre></td></tr></table></figure><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><ul><li>含义：永远不存在的值的类型。</li><li>应用场景：一个从来不会有返回值的函数（函数内含有 <code>while(true)&#123;&#125;</code>），一个总是抛出错误的函数(<code>function fn()&#123;throw new Error(&#39;xxxx&#39;)&#125;</code>)</li></ul><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params"><span class="hljs-attr">message</span>: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">never</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>never 类型不能被其他类型赋值，只能 never 类型赋值给 never 类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">never</span> = <span class="hljs-string">&quot;chenjiang&quot;</span>; <span class="hljs-comment">// 报错：number 类型不能赋值给 never 类型</span><br><br><span class="hljs-keyword">let</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">never</span> = (<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;报错了&quot;</span>);<br>&#125;)(); <span class="hljs-comment">// 这样是可以</span><br></code></pre></td></tr></table></figure>          </div><h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><ul><li>含义：它表示没有任何类型，一般在函数中使用，表示函数没有返回值。</li><li>应用场景：一般用于没有返回值的函数的返回值类型上。</li></ul><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">function</span> <span class="hljs-title function_">tip</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;tip message&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>由此看来 void 和 never 很类似，到底有什么区别呢？</p><ul><li>never 表示永远不存在的值的类型，函数总是抛出错误、一直处于循环，有值也返回不了，所以说永远不存在的值的类型</li><li>never 类型不能被其它类型赋值，只能被 never 类型赋值</li><li>void 表示没有任何类型，函数没有任何返回值。</li><li>void 可以被其它类型赋值</li></ul>          </div><h2 id="unknow"><a href="#unknow" class="headerlink" title="unknow"></a>unknow</h2><ul><li>含义：表示任何类型，和 any 类型，但是它比 any 安全，因为 unknow 类型的值执行很多操作是不被允许的，直到我们通过类型检查缩小了该值的类型。</li><li>应用场景：不想设置值的类型，又想要求别人使用这个对象的时候要先做类型判断，可以把它做为 any 类型的安全版本。</li></ul><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">info</span>: unknow = <span class="hljs-number">26</span>;<br>info.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// Error: unknow对象不能直接访问上面的属性</span><br><br><span class="hljs-comment">// 上面提到的应用场景</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">info</span>: unknow = <span class="hljs-number">26</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> info === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>  info.<span class="hljs-title function_">toFixed</span>(<span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>unknow 类型 不能直接赋值给非 any 和 unknow 类型</p>          </div><h2 id="null、undefined"><a href="#null、undefined" class="headerlink" title="null、undefined"></a>null、undefined</h2><ul><li>含义：null 表示无值的特殊值，undefined 表示未定义。</li></ul><p>示例：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> <span class="hljs-attr">empty</span>: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">name</span>: <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Typescript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>水印功能实现</title>
    <link href="/js/watermask/"/>
    <url>/js/watermask/</url>
    
    <content type="html"><![CDATA[<h1 id="水印功能实现"><a href="#水印功能实现" class="headerlink" title="水印功能实现"></a>水印功能实现</h1><p>应业务要求，需要根据登录用户的名称、角色、当前日期生成水印功能。</p><p>大致样子：</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409091102018.png" alt="水印样式"></p><h2 id="分析思路"><a href="#分析思路" class="headerlink" title="分析思路"></a>分析思路</h2><p>系统上重复展示名称、角色、日期，首先我们要生成这些内容，然后无限重复，大致可能分成两个步骤：</p><ul><li>利用 canvas 绘制文字，然后生成图片。</li><li>系统背景使用这个图片，并且 x 和 y 轴重复。</li></ul><h2 id="根据提供信息绘制-canvas"><a href="#根据提供信息绘制-canvas" class="headerlink" title="根据提供信息绘制 canvas"></a>根据提供信息绘制 canvas</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>canvas.<span class="hljs-property">width</span> = len * fontSize; <span class="hljs-comment">// canvas宽度, 目前是根据文字长度和大小来调整的, 自己可依照具体需求变动</span><br>canvas.<span class="hljs-property">height</span> = height + fontSize * <span class="hljs-number">2.8</span>; <span class="hljs-comment">// canvas高度, 依据需求调整</span><br><br><span class="hljs-keyword">const</span> context = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>context.<span class="hljs-title function_">translate</span>(<span class="hljs-number">0</span>, canvas.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>); <span class="hljs-comment">// 改变旋转基点</span><br>context.<span class="hljs-title function_">rotate</span>((-rotate * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / <span class="hljs-number">180</span>); <span class="hljs-comment">// 进行旋转, 传过来的旋转角度</span><br>context.<span class="hljs-property">font</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;fontSize&#125;</span>px Vedana`</span>; <span class="hljs-comment">// 设置字体</span><br>context.<span class="hljs-property">fillStyle</span> = color; <span class="hljs-comment">// 设置文字颜色</span><br><br><span class="hljs-comment">// 将需要的文本, 绘制到canvas上面</span><br>context.<span class="hljs-title function_">fillText</span>(text, <span class="hljs-number">10</span>, canvas.<span class="hljs-property">height</span> / <span class="hljs-number">2</span> - <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><h2 id="将-canvas-做为遮罩层背景图"><a href="#将-canvas-做为遮罩层背景图" class="headerlink" title="将 canvas 做为遮罩层背景图"></a>将 canvas 做为遮罩层背景图</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 生成水印遮罩层</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>div.<span class="hljs-property">id</span> = <span class="hljs-variable constant_">DOM_ID</span>;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">pointerEvents</span> = <span class="hljs-string">&quot;none&quot;</span>;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&quot;fixed&quot;</span>;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span> = zIndex;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&quot;-32%&quot;</span>;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">&quot;-32%&quot;</span>;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = opacity;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&quot;150%&quot;</span>;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&quot;150%&quot;</span>;<br>div.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">`url(&#x27;<span class="hljs-subst">$&#123;canvas.toDataURL(<span class="hljs-string">&quot;images/png&quot;</span>)&#125;</span>&#x27;)repeat left top`</span>;<br><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);<br></code></pre></td></tr></table></figure><h2 id="防止篡改水印信息"><a href="#防止篡改水印信息" class="headerlink" title="防止篡改水印信息"></a>防止篡改水印信息</h2><p>利用<code>MutationObserverAPI</code>来对遮罩层做监听, 防止属性修改或者 dom 节点被人为的删除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 监听dom变化, 防止水印被篡改</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> observeDomChange = <span class="hljs-function">(<span class="hljs-params">waterMarkDom, options</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">mutationsList, observer</span>) =&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> mutation <span class="hljs-keyword">of</span> mutationsList) &#123;<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 水印节点的属性发生了变动</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">if</span> (mutation.<span class="hljs-property">target</span> === waterMarkDom) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setWaterMark</span>(); <span class="hljs-comment">// 重新生成水印</span><br>        observer.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// 停止观察</span><br>      &#125;<br><br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 强行手动删除了水印节点</span><br><span class="hljs-comment">       */</span><br>      <span class="hljs-keyword">if</span> (mutation.<span class="hljs-property">removedNodes</span>.<span class="hljs-property">length</span> &amp;&amp; mutation.<span class="hljs-property">removedNodes</span>[<span class="hljs-number">0</span>] === waterMarkDom) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setWaterMark</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>); <span class="hljs-comment">// 重新生成水印</span><br>        observer.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// 停止观察</span><br>      &#125;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">observer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br><br>  <span class="hljs-comment">/** 监听body */</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">observer</span>.<span class="hljs-title function_">observe</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>), &#123;<br>    <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 观察属性变动</span><br>    <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 观察目标子节点的变化，是否有添加或者删除</span><br>    <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 观察后代节点，默认为 false</span><br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h2>    <div class="fold">      <div class="fold-title fold-success collapsed" data-toggle="collapse" href="#collapse-5b75660a" role="button" aria-expanded="false" aria-controls="collapse-5b75660a">        <div class="fold-arrow">▶</div>所有代码      </div>      <div class="fold-collapse collapse" id="collapse-5b75660a">        <div class="fold-content">          <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DOM_ID</span> = <span class="hljs-string">&quot;yss-cj-create&quot;</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 水印的默认属性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">DEFAULT_OPTIONS</span> = &#123;<br>  <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;cxk  管理员  20230424&quot;</span>,<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">520</span>, <span class="hljs-comment">// 水印块的宽度</span><br>  <span class="hljs-attr">height</span>: <span class="hljs-number">280</span>, <span class="hljs-comment">// 水印块的高度</span><br>  <span class="hljs-attr">rotate</span>: <span class="hljs-number">20</span>, <span class="hljs-comment">// 水印块的旋转角度</span><br>  <span class="hljs-attr">fontSize</span>: <span class="hljs-number">28</span>, <span class="hljs-comment">// 文字大小</span><br>  <span class="hljs-attr">color</span>: <span class="hljs-string">&quot;#666&quot;</span>, <span class="hljs-comment">// 文字颜色</span><br>  <span class="hljs-attr">opacity</span>: <span class="hljs-string">&quot;0.3&quot;</span>, <span class="hljs-comment">// 遮罩层的透明度</span><br>  <span class="hljs-attr">zIndex</span>: <span class="hljs-string">&quot;9999999999&quot;</span>, <span class="hljs-comment">// 遮罩层的层级</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watermark</span> &#123;<br>  options = &#123;&#125;;<br>  observer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 生成水印</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> setWaterMark = <span class="hljs-function">(<span class="hljs-params">options = &#123;&#125;</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> waterDom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-variable constant_">DOM_ID</span>);<br>    <span class="hljs-keyword">if</span> (waterDom !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 每次重新绘制之前, 需要判断是否已经存在, 如果存在了就先删除, 再来重新绘制</span><br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(waterDom);<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> latestOptions = &#123; ...<span class="hljs-variable constant_">DEFAULT_OPTIONS</span>, ...options &#125;;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span> = latestOptions;<br><br>    <span class="hljs-keyword">const</span> &#123;<br>      text,<br>      width, <span class="hljs-comment">// 宽度是根据提供的文字大小和文字长度计算出来的, 这里就用不上了</span><br>      height, <span class="hljs-comment">// 水印块的高度</span><br>      rotate, <span class="hljs-comment">// 水印块的旋转角度</span><br>      fontSize, <span class="hljs-comment">// 文字大小</span><br>      color, <span class="hljs-comment">// 文字颜色</span><br>      opacity, <span class="hljs-comment">// 遮罩层的透明度</span><br>      zIndex, <span class="hljs-comment">// 遮罩层的层级</span><br>    &#125; = latestOptions;<br><br>    <span class="hljs-keyword">const</span> len = text.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;canvas&quot;</span>);<br>    canvas.<span class="hljs-property">width</span> = len * fontSize;<br>    canvas.<span class="hljs-property">height</span> = height + fontSize * <span class="hljs-number">2.8</span>;<br><br>    <span class="hljs-keyword">const</span> context = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&quot;2d&quot;</span>);<br>    context.<span class="hljs-title function_">translate</span>(<span class="hljs-number">0</span>, canvas.<span class="hljs-property">height</span> / <span class="hljs-number">2</span>);<br>    context.<span class="hljs-title function_">rotate</span>((-rotate * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span>) / <span class="hljs-number">180</span>);<br>    context.<span class="hljs-property">font</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;fontSize&#125;</span>px Vedana`</span>; <span class="hljs-comment">// 设置字体</span><br>    context.<span class="hljs-property">fillStyle</span> = color; <span class="hljs-comment">// 设置文字颜色</span><br><br>    <span class="hljs-comment">// 将需要的文本, 绘制到canvas上面</span><br>    context.<span class="hljs-title function_">fillText</span>(text, <span class="hljs-number">10</span>, canvas.<span class="hljs-property">height</span> / <span class="hljs-number">2</span> - <span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">// 生成水印遮罩层</span><br>    <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);<br>    div.<span class="hljs-property">id</span> = <span class="hljs-variable constant_">DOM_ID</span>;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">pointerEvents</span> = <span class="hljs-string">&quot;none&quot;</span>;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">position</span> = <span class="hljs-string">&quot;fixed&quot;</span>;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">zIndex</span> = zIndex;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&quot;-32%&quot;</span>;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">&quot;-32%&quot;</span>;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">opacity</span> = opacity;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = <span class="hljs-string">&quot;150%&quot;</span>;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = <span class="hljs-string">&quot;150%&quot;</span>;<br>    div.<span class="hljs-property">style</span>.<span class="hljs-property">background</span> = <span class="hljs-string">`url(&#x27;<span class="hljs-subst">$&#123;canvas.toDataURL(<span class="hljs-string">&quot;images/png&quot;</span>)&#125;</span>&#x27;)repeat left top`</span>;<br><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 监听水印的dom变化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">observeDomChange</span>(div);<br>  &#125;;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 去除水印</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">static</span> removeWatermark = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> dom = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-variable constant_">DOM_ID</span>);<br>    <span class="hljs-keyword">if</span> (dom !== <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(dom);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 监听dom变化, 防止水印被篡改</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">static</span> observeDomChange = <span class="hljs-function">(<span class="hljs-params">waterMarkDom, options</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">callback</span> = (<span class="hljs-params">mutationsList, observer</span>) =&gt; &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> mutation <span class="hljs-keyword">of</span> mutationsList) &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 水印节点的属性发生了变动</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (mutation.<span class="hljs-property">target</span> === waterMarkDom) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setWaterMark</span>(); <span class="hljs-comment">// 重新生成水印</span><br>          observer.<span class="hljs-title function_">disconnect</span>(); <span class="hljs-comment">// 停止观察</span><br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 强行手动删除了水印节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (mutation.<span class="hljs-property">removedNodes</span>.<span class="hljs-property">length</span> &amp;&amp; mutation.<span class="hljs-property">removedNodes</span>[<span class="hljs-number">0</span>] === waterMarkDom) &#123;<br>          <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setWaterMark</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>); <span class="hljs-comment">// 重新生成水印</span><br>          observer.<span class="hljs-title function_">disconnect</span>();<br>        &#125;<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observer</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutationObserver</span>(callback);<br><br>    <span class="hljs-comment">/** 监听body */</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">observer</span>.<span class="hljs-title function_">observe</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&quot;body&quot;</span>), &#123;<br>      <span class="hljs-attr">attributes</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 观察属性变动</span><br>      <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 观察目标子节点的变化，是否有添加或者删除</span><br>      <span class="hljs-attr">subtree</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 观察后代节点，默认为 false</span><br>    &#125;);<br>  &#125;;<br>&#125;<br><br><span class="hljs-title class_">Watermark</span>.<span class="hljs-title function_">setWaterMark</span>();<br></code></pre></td></tr></table></figure>        </div>      </div>    </div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>业务功能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React状态提升、Context使用及带来的问题分析与解决</title>
    <link href="/react/state-context/"/>
    <url>/react/state-context/</url>
    
    <content type="html"><![CDATA[<h1 id="React-状态提升、Context-使用及带来的问题分析与解决"><a href="#React-状态提升、Context-使用及带来的问题分析与解决" class="headerlink" title="React 状态提升、Context 使用及带来的问题分析与解决"></a>React 状态提升、Context 使用及带来的问题分析与解决</h1><p>在我们平时开发中，避免不了一种场景就是组件状态共享，A 和 B 两个组件有公共的状态，常见的处理方法：</p><h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>将公共的 state 提升至它们的公共祖先，由祖先提供 state 和修改 state 的逻辑，这样有可能导致重新渲染一颗巨大的组件树。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title function_">A</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;child1 更新了&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>A组件 &#123;props.value.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">B</span> = (<span class="hljs-params">props</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;child2 更新了&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>B组件 &#123;props.value.age&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">A</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">B</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      &#123;/* 不依赖value的子组件 */&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">C</span> <span class="hljs-attr">xxxProps</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">D</span> <span class="hljs-attr">xxxProps</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setValue(&#123; ...value, name: &quot;chenjiang666&quot; &#125;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改name</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-default">            <p>当我们更新 value 时候，父组件会重新渲染，由于 A 和 B 两个组件都依赖了也会随着重新渲染，但是父组件还有一些不依赖的 value 的子组件也进行不必要的渲染。</p>          </div><h3 id="如何减少不必要的渲染"><a href="#如何减少不必要的渲染" class="headerlink" title="如何减少不必要的渲染"></a>如何减少不必要的渲染</h3><p>不依赖 value 的子组件：C、D 这两个组件</p><p>我们对 C、D 组件用 React.memo 包裹，保证它的 props 没有发生变化的时候不会重新渲染，但是由于父组件更新了导致函数重新执行，那么 C、D 组件放在父组件的 props 引用发生变化，也会导致重新渲染，所以说并不是组件被 React.memo 包裹了就万事俱备了，还需要对放在父组件的 props 用 useMemo 或者 useCallback 包裹。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> C = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>123213<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;);<br><br>  <span class="hljs-keyword">const</span> cState = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, []);<br>  <span class="hljs-keyword">const</span> handleC = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, []);<br>  <span class="hljs-keyword">const</span> handleD = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, []);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">A</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">B</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span> /&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">C</span> <span class="hljs-attr">handleC</span>=<span class="hljs-string">&#123;handleC&#125;</span> <span class="hljs-attr">cState</span>=<span class="hljs-string">&#123;cState&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">D</span> <span class="hljs-attr">handleD</span>=<span class="hljs-string">&#123;handleD&#125;</span> /&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setValue(&#123; ...value, name: &quot;chenjiang666&quot; &#125;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改name</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注：一般来说 React.memo 都是要和 useMemo 或者 useCallback 配合来使用的。</strong></p><h2 id="使用-Context"><a href="#使用-Context" class="headerlink" title="使用 Context"></a>使用 Context</h2><p>将公共状态放到 Provider 组件的 value 里面，然后包裹需要此状态的组件，可能引起不必要的渲染</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AppContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">theme</span>: <span class="hljs-string">&quot;dark&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AppContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Theme</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">AppContext.Provider</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setValue(&#123; ...value, theme: value.theme === &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot; &#125;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改主题色</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-default">            <p>当前 value 更新，Provider 就会重新渲染，其包裹的组件也随着重新渲染，但是有组件所依赖的状态并没有改变，导致了不必要的渲染。</p><p>例如：Theme 组件依赖 value 的 theme 属性，Person 组件依赖 value 的 age、name 属性，有一次更新了 value.theme 导致 value 引用发生了改变，就导致 Provider 及其子组件都更新了，Person 组件其实并不依赖 theme 属性但是也更新了，这就造成了不必要的渲染。</p>          </div><h3 id="如何减少不必要的渲染-1"><a href="#如何减少不必要的渲染-1" class="headerlink" title="如何减少不必要的渲染"></a>如何减少不必要的渲染</h3><p>为什么存在不必要的渲染，其实本质就是用了自己本不需要的 props，需要做的就是拆分，各取所需。</p><h4 id="拆分-Context"><a href="#拆分-Context" class="headerlink" title="拆分 Context"></a>拆分 Context</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AppContext</span> = <span class="hljs-title function_">createContext</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">InfoContext</span> = <span class="hljs-title function_">createContext</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [theme, setTheme] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">theme</span>: <span class="hljs-string">&quot;dark&quot;</span> &#125;);<br>  <span class="hljs-keyword">const</span> [info, setInfo] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;);<br><br>  <span class="hljs-keyword">const</span> cState = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, []);<br>  <span class="hljs-keyword">const</span> handleC = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, []);<br><br>  <span class="hljs-keyword">const</span> handleD = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;&#125;, []);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AppContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;theme&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">A</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">AppContext.Provider</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">InfoContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;info&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">B</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">InfoContext.Provider</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setTheme(&#123; theme: theme.theme === &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot; &#125;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改主题色</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="提取独有的状态-React-memo"><a href="#提取独有的状态-React-memo" class="headerlink" title="提取独有的状态 React.memo"></a>提取独有的状态 React.memo</h4><p>memo 允许你的组件在 props 没有改变的情况下跳过重新渲染。</p><p>把当前组件所需要的状态，单独从 Context 提取出来，以 props 形式传递，然后对组件 React.memo 包裹，但是如果组件多了话，每个都需要单独拎出来进行处理。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">P</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;props.theme&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">theme</span>: <span class="hljs-string">&quot;dark&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AppContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;/* 所需要的状态单独提取出来 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Theme</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;value.theme&#125;</span> /&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">AppContext.Provider</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setValue(&#123; ...value, theme: value.theme === &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot; &#125;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改主题色</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="提取独有的状态-useMemo"><a href="#提取独有的状态-useMemo" class="headerlink" title="提取独有的状态 useMemo"></a>提取独有的状态 useMemo</h4><p>useMemo 是一个 Hook，可以缓存计算的结果，只有依赖发生变化了，才会重新计算。我们可以利用这个特性，对组件进行缓存，只有它所需要的状态发生变化，才去更新组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [value, setValue] = <span class="hljs-title function_">useState</span>(&#123; <span class="hljs-attr">theme</span>: <span class="hljs-string">&quot;dark&quot;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">26</span> &#125;);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">AppContext.Provider</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;value&#125;</span>&gt;</span></span><br><span class="language-xml">        &#123;/* 所需要的状态单独提取出来 */&#125;</span><br><span class="language-xml">        &#123;useMemo(</span><br><span class="language-xml">          () =&gt; (</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">UserPage</span> <span class="hljs-attr">theme</span>=<span class="hljs-string">&#123;value.theme&#125;</span> /&gt;</span></span><br><span class="language-xml">          ),</span><br><span class="language-xml">          [value.theme]</span><br><span class="language-xml">        )&#125;</span><br><span class="language-xml"></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">Person</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">AppContext.Provider</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span></span></span><br><span class="hljs-tag"><span class="language-xml">        <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> &#123;</span><br><span class="language-xml">          setValue(&#123; ...value, theme: value.theme === &quot;dark&quot; ? &quot;light&quot; : &quot;dark&quot; &#125;);</span><br><span class="language-xml">        &#125;&#125;</span><br><span class="language-xml">      &gt;</span><br><span class="language-xml">        修改主题色</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React状态管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端需了解的HTTP知识</title>
    <link href="/http/http-tcp-https/"/>
    <url>/http/http-tcp-https/</url>
    
    <content type="html"><![CDATA[<h1 id="前端需了解的网络知识"><a href="#前端需了解的网络知识" class="headerlink" title="前端需了解的网络知识"></a>前端需了解的网络知识</h1><h2 id="HTTP-版本发展过程"><a href="#HTTP-版本发展过程" class="headerlink" title="HTTP 版本发展过程"></a>HTTP 版本发展过程</h2><h3 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h3><p>● 新增了 POST 请求方式<br>● 新增了请求头、http 状态码<br>● 新增了 cookie</p><h3 id="HTTP1-1"><a href="#HTTP1-1" class="headerlink" title="HTTP1.1"></a>HTTP1.1</h3><p>● 新增了 keep-alive 长连接<br>● 新增了 pipeline 管道<br>● 新增了 PUT、DELETE、OPTIONS、PATCH 等新的请求方式</p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>● 头部支持二进制协议、支持头部压缩<br>● 新增了多路复用</p><h3 id="HTTP1-1-有哪些特点"><a href="#HTTP1-1-有哪些特点" class="headerlink" title="HTTP1.1 有哪些特点"></a>HTTP1.1 有哪些特点</h3><p>● 默认开启了长连接 Connection: keep-alive，TCP 连接复用，可以被多个请求服用，避免了连接建立和释放带来的开销。<br>● 支持 pipeline 管道传输，可以不必等待请求响应了才能发起下一个请求，但是响应的时候必须按照发送顺序接收，一旦有一请求个丢包了，后面的都会被卡住。<br>● 并发连接：浏览器会同时和服务器建立多个 TCP 连接，在同一个 TCP 连接上顺序处理多个 HTTP 请求。<br>● 增加了 PUT、DELETE、OPTIONS、PATCH 方法<br>● 新增了一些缓存字段（If-Modified-Since、If-None-Match）<br>● 请求头引入 range 字段，支持断点续传<br>● 允许响应数据分块（chunked），利于传输大文件</p><h3 id="HTTP2-0-有哪些特点"><a href="#HTTP2-0-有哪些特点" class="headerlink" title="HTTP2.0 有哪些特点"></a>HTTP2.0 有哪些特点</h3><p>● 二进制协议：HTTP1.1 版本的头部信息是文本，数据部分可以是文本也可以是二进制。HTTP2 版本的头部和数据部分都是二进制，且统称为“帧”。<br>● 多路复用：HTTP1.1 使用 pipeline 管道机制，虽然可以同一个 TCP 发多个请求，但是响应的顺序要和请求的顺序一致，一旦某个请求响应嘎了，那后面的响应客户端接收不到，这就是“队头阻塞”问题。HTTP2.0 采用多路复用，就不用按照顺序来，避免了“队头阻塞”的问题。<br>● 头部信息压缩：使用算法压缩头部，减少数据传输量。<br>● 服务端主动推送：允许服务端主动向客户端推送数据。<br>● 数据流：服务器以流的 stream 的形式向客户端返回内容。</p><h3 id="HTTP3-0-有哪些特点"><a href="#HTTP3-0-有哪些特点" class="headerlink" title="HTTP3.0 有哪些特点"></a>HTTP3.0 有哪些特点</h3><p>首先 HTTP 是基于 TCP 协议实现的。<br>TCP 主要的作用是以正确的顺序将整个字节流从一个端传输到另外一个端（服务端-&gt;客户端），当流中的某些数据包丢失了，导致后续的数据包没有按顺序到达一端，服务端就要那就要等 TCP 需要重新发送这些丢失的数据包，等到所有的数据包到了另一个端的时候才会被 HTTP 处理，这被称为<code>TCP 队头阻塞</code>问题。<br><strong>注：HTTP2.0 多路复用解决的是 HTTP 队头阻塞问题。</strong></p><p>HTTP3.0 就是为了解决 TCP 队头阻塞问题，发明了一个基于 UDP 协议的 QUIC 协议，特征就是快。<br>HTTP 是基于 TCP 协议的，TCP 建立连接是需要三次握手的。<br>QUIC 是基于 UDP 协议的，它不需要三次握手，减少时间延迟。</p><p>所以来看 HTTP3.0 主要是：<br>● 使用了 UDP 协议，不需要建立三次握手，缩短了 HTTPS 建立连接的时间<br>● 解决了队头阻塞问题，TCP 传输过程中，某个数据包丢失了，后续数据包就会被接收端一直保持着，直到丢失的数据包重新发送并到达了接收端为止，这种情况就导致了后续数据包延迟传输，就是为了保证按照发送的顺序来接收数据。</p><h2 id="HTTP2-0-为什么要使用分帧层"><a href="#HTTP2-0-为什么要使用分帧层" class="headerlink" title="HTTP2.0 为什么要使用分帧层"></a>HTTP2.0 为什么要使用分帧层</h2><p><a href="https://github.com/strongcode9527/blog/issues/6">参考文章</a></p><p>● 二进制协议比文本协议更紧凑，减少占用空间。<br>● 分帧层相当于把 HTTP 切分了，更加灵活。<br>● 分帧层有着属于自己的报文头，其中的 Stream Identifier 使得操作系统具备将多个响应以及请求一一匹配的能力，这个是 http&#x2F;2 性能提升的关键，也就是多路复用。</p><h2 id="什么是长连接？keep-alive"><a href="#什么是长连接？keep-alive" class="headerlink" title="什么是长连接？keep-alive"></a>什么是长连接？keep-alive</h2><p>TCP 每次连接都要经历三次握手，而每次发请求和响应都要重新建立连接，开销很大。<br>如果开启了长连接，就可以避免，只需要三次握手一次，就可以进行多次请求和响应。</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041051121.png" alt="长连接"></p><h2 id="什么是-Pipelining-管道传输"><a href="#什么是-Pipelining-管道传输" class="headerlink" title="什么是 Pipelining 管道传输"></a>什么是 Pipelining 管道传输</h2><p>可以同时发送多个请求，不需要等有结果了才能发第二个请求，但是响应结果必须和发请求的顺序一致，一旦出现某个请求丢包了（网络问题等），就会导致后面的请求卡住。</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041101303.png"></p><h2 id="pipeline-管道传输和-HTTP2-0-多路复用的区别"><a href="#pipeline-管道传输和-HTTP2-0-多路复用的区别" class="headerlink" title="pipeline 管道传输和 HTTP2.0 多路复用的区别"></a>pipeline 管道传输和 HTTP2.0 多路复用的区别</h2><p><strong>注：pipeline 技术是基于长连接。</strong></p><p>首先看一下，有没有 pipeline 的区别</p><p>● 没有使用 pipeline，每次发一条请求，必须要收到响应，才能发下一条请求。<br>● 使用了 pipeline，可以发多条请求，但是收到的响应顺序必须是和发的顺序是一致的，一旦某条响应数据卡住了（网络原因等问题），就会导致后面的响应数据都被卡住了，这就是“队头阻塞”问题。</p><p>HTTP2.0 多路复用是怎么处理的？</p><p>● http2.0 全面采用二进制分帧形式，假如请求 1 需要收到响应的数据是【1-1，1-2，1-3】，没有多路复用的话，那么收到的必须是完整且有顺序的【1-1，1-2，1-3】这样才算结束。有了多路复用结束过后，我们收到的数据可以不需要完整和有序，收到的数据 1-1，2-1，1-2，3-1，1-3，2-2，最后 http 会自己把数据组装成【1-1，1-2，1-3】交给请求 1。一句话概括：收到的数据不需要和发出去的顺序一致。</p><h2 id="浏览器-http-请求的并发性是如何体现的？并发请求的数量有没有限制？"><a href="#浏览器-http-请求的并发性是如何体现的？并发请求的数量有没有限制？" class="headerlink" title="浏览器 http 请求的并发性是如何体现的？并发请求的数量有没有限制？"></a>浏览器 http 请求的并发性是如何体现的？并发请求的数量有没有限制？</h2><p>页面资源请求的时，浏览器会同时和服务器建立多个 TCP 连接，在同一个 TCP 连接上顺序处理多个 HTTP 请求。所以浏览器的并发性就体现在可以建立多个 TC 连接，来支持多个 HTTP 同时请求。</p><p><strong>谷歌浏览器最多允许对同一个域名建立 6 个 TCP 连接。</strong></p><h2 id="一个-TCP-连接可以同时发送几个-HTTP-请求？"><a href="#一个-TCP-连接可以同时发送几个-HTTP-请求？" class="headerlink" title="一个 TCP 连接可以同时发送几个 HTTP 请求？"></a>一个 TCP 连接可以同时发送几个 HTTP 请求？</h2><p>一般来说单个 TCP 连接，同一时间只能处理一个 HTTP 请求，虽然我们知道 HTTP1.1 有个 Pipelining 管道机制，可以同时发多个请求，实践中存在很多问题（响应的顺序和请求的顺序保持一致，如果响应的时候有一个请求嘎了，那后面的响应都会丢失），所以浏览器默认是关闭的，因此可以认为是不支持同时发多个请求的。<br>HTTP2 提供了多路复用，可以同时在同一个 TCP 连接上发多个 HTTP 请求。</p><h2 id="TCP-和-UDP-区别"><a href="#TCP-和-UDP-区别" class="headerlink" title="TCP 和 UDP 区别"></a>TCP 和 UDP 区别</h2><p>● TCP 是面向连接，提供可靠的服务，UDP 是无连接的，发送数据前是不需要建立连接，UDP 尽量最大交付，但是不保证可靠交付。<br>● UDP 具有较好的实时性，工作效率比 TCP 高。</p><div class="note note-primary">            <p>UDP 应用场景：直播、游戏<br>TCP 应用场景：网页</p>          </div><p>● TCP 连接只能一对一，一个客户端对应一个服务端，UDP 可以一对一，一对多，多对一，多对多的交互通信<br>● TCP 是面向字节流的，将数据包一点一点传递给另外一个端，UDP 是面向报文的一次交付一个完整的报文。</p><h2 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h2><p>TCP 是面向连接的，在使用 TCP 前必须要建立连接，而建立连接是通过三次握手来进行的，过程如下：</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041112447.png" alt="三次握手、四次挥手"></p><p>● 第一次握手：客户端发送 SYN 包（SYN &#x3D; x）到服务器，并且进入 SYN_SENT 状态，等待服务器确认<br>● 第二次握手：服务器收到 SYN 包，必须确认客户端的 SYN 包（ACK &#x3D; x + 1），同时自己也发送一个 SYN 包（SYN &#x3D; y），即发送给客户端的就是（SYN + ACK）包，此时服务器进入 SYN_RECV 状态（receive）<br>● 第三次握手：客户端收到了服务端的 SYN + ACK 包，向服务器发送确认包（ACK &#x3D; y + 1）, 发送完毕过后，客户端和服务端就进入 ESTABLISHED 状态。</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>主要是为了建立可靠的通信，目的就是双方确认与对方发的发送和接收是正常的。假如只有两次握手，那么服务端就不知道客户端是否具有接收数据的能力。</p><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>参考文档：</p><ul><li><a href="https://blog.51cto.com/u_15656645/5427516">深入浅出 TCP 四次挥手 （多图详解）</a></li><li><a href="https://www.cnblogs.com/wujing-hubei/p/5699773.html">TCP 三次握手、四次挥手及状态转换图</a></li></ul><p>流程图如上<br>四次握手分析如下：</p><ol><li>客户端发送 FIN 包（FIN &#x3D; x + 2）和 ACK（ACK &#x3D; y + 1）到服务器，告诉服务器我需要关闭连接，此时处于半关闭状态（FIN-WAIT-1）。（此时还是可以接受服务端传过来的数据）。</li><li>服务器收到 FIN 包和 ACK 包后，发送一个 ACK（ACK &#x3D; x + 3）针对上一次 FIN 的回应给客户端，好的我收到，我还有数据没传完，要等一下，此时服务器进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态</li><li>过了一会，再给客户端发送一个 FIN（FIN &#x3D; y + 1），表示服务端的数据都发送完了，释放连接。服务器结束 CLOSE-WAIT 状态，进入 LAST-ACK 状态。</li><li>客户端收到客户端的 FIN（FIN &#x3D; y + 1），确认了服务端做好了释放连接的准备，于是结束 FIN-WAIT-2 状态，进入 TIME-WAIT 阶段，并向服务端发送 ACK 包（ACK &#x3D; y + 2）表示可以释放连接了。<br>随后客户端在 TIME-WAIT 阶段等待 2MSL，等服务端收到客户端的 ACK 包过后，服务端就进入 CLOSED 阶段，正式关闭连接。客户端 2MSL 后也进入 CLOSED 阶段。</li></ol><h3 id="第二次和第三次挥手为什么要分开？为什么要合并？"><a href="#第二次和第三次挥手为什么要分开？为什么要合并？" class="headerlink" title="第二次和第三次挥手为什么要分开？为什么要合并？"></a>第二次和第三次挥手为什么要分开？为什么要合并？</h3><p>为了数据传输的完整性，第一次挥手，服务端收到断开连接的请求，但是很有可能服务端的数据还没有传完，要过一会，等所有数据都传完，服务端才能断开连接。</p><h3 id="第四次挥手发送完最后一个报文，为什么不直接进入关闭状态？而是要进入等待时间，2MSL-后才进入关闭状态？"><a href="#第四次挥手发送完最后一个报文，为什么不直接进入关闭状态？而是要进入等待时间，2MSL-后才进入关闭状态？" class="headerlink" title="第四次挥手发送完最后一个报文，为什么不直接进入关闭状态？而是要进入等待时间，2MSL 后才进入关闭状态？"></a>第四次挥手发送完最后一个报文，为什么不直接进入关闭状态？而是要进入等待时间，2MSL 后才进入关闭状态？</h3><p>最后一次挥手完成过后，客户端并不知道服务端有没有接收到，很有可能存在网络出现问题，导致 ACK 报文没有接收到，服务端会重新发送 FIN，客户端会再次发送 ACK，TIME-WAIT 的 2MSL 使用来重发可能丢失的 ACK 报文的。</p><h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3><p>是因为服务端 FIN 断开连接和 ACK 确认接受报文是分别在两次挥手中传输的。是为了保证服务端传递数据的完整性。先回复给客户端我这边已经收到释放连接的请求（发送 ACK 包），但是要过一会，等数据都传输完毕，完毕过后过后告诉客户端传输完成了，我可以关闭了（发送 FIN 包）</p><h2 id="HTTPS-加密过程"><a href="#HTTPS-加密过程" class="headerlink" title="HTTPS 加密过程"></a>HTTPS 加密过程</h2><div class="note note-success">            <p>前置知识<br>对称加密：只有一把钥匙，既可以加密也可以解密。<br>非对称加密：有两把钥匙，一把钥匙用于加密（公钥），一把钥匙用于解密（私钥）。</p>          </div><p>加密过程</p><ol><li>客户端发起一个 http 请求</li><li>服务端返回一个数字证书给客户端（证书包含公钥、网站地址、证书颁发机构、失效日期等）。证书里面有一个公钥用来加密信息的，服务端持有一个私钥用来解密的。</li><li>客户端收到证书后，会先验证证书的合法性（证书包含的地址和正在访问的地址是否一次，是否过期）。</li><li>验证通过后，客户端随机生成一个对称密钥（随机字符串），然后用公钥进行加密，传给服务端进行解密，服务端就可以拿到这个对称秘钥。</li><li>上一步客户端和服务端都拥有了一个对称秘钥（随机字符串），后续的传输内容都根据这个秘钥来进行对称加密。</li></ol><h2 id="https-是绝对安全的吗？"><a href="#https-是绝对安全的吗？" class="headerlink" title="https 是绝对安全的吗？"></a>https 是绝对安全的吗？</h2><p>有一种攻击手段叫做中间人攻击。<br>通俗一点描述：这个中间人对浏览器冒充服务器，对服务器冒充浏览器。这样就可以拿到通信数据了，并且可以篡改。</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041116983.png" alt="中间人攻击流程"></p><p>分析过程：</p><ol><li>浏览器发请求，申请获得证书。</li><li>服务端返回一个数字证书给客户端（证书包含公钥 A、网站地址、证书颁发机构、失效日期等）。</li><li>但是直接被中间人拦截了，截取了公钥 A，然后中间人自己生成了一个公钥 B，并发送给客户端。</li><li>客户端生成一个对称密钥 X（随机字符串），并用公钥 B 进行加密，发送给服务端，此时被中间人拦截了，并且用公钥 B 解密，因此可以得到对称秘钥 X。</li><li>然后中间人中公钥 A 加密对称秘钥 X，给服务端，后端的通信都是通过这个对称秘钥 X 进行对称加密。</li></ol>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优化构建速度</title>
    <link href="/project/build-speed/"/>
    <url>/project/build-speed/</url>
    
    <content type="html"><![CDATA[<h1 id="如何优化构建速度"><a href="#如何优化构建速度" class="headerlink" title="如何优化构建速度"></a>如何优化构建速度</h1><h2 id="优化-loader-匹配范围"><a href="#优化-loader-匹配范围" class="headerlink" title="优化 loader 匹配范围"></a>优化 loader 匹配范围</h2><p>在使用 loader 时，可以通过配置 include、exclude、test 属性来匹配文件，接触 include、exclude 规定哪些匹配应用 loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-comment">// 如果项目源码中只有 js 文件就不要写成 /\.jsx?$/，提升正则表达式性能</span><br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        <span class="hljs-comment">// babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启</span><br>        <span class="hljs-attr">use</span>: [<span class="hljs-string">&quot;babel-loader?cacheDirectory&quot;</span>],<br>        <span class="hljs-comment">// 只对项目根目录下的 src 目录中的文件采用 babel-loader</span><br>        <span class="hljs-attr">include</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;src&quot;</span>),<br>      &#125;,<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合理配置-resolve-extensions"><a href="#合理配置-resolve-extensions" class="headerlink" title="合理配置 resolve.extensions"></a>合理配置 resolve.extensions</h2><p>它的主要作用，就是写 import、required 时候不用加上文件后缀名。当我们引入文件时候没有文件后缀名，就会根据 extensions 依次查找。</p><p>如果这个后缀名很多，就会调用多次文件查找，这样就会减慢打包速度。按需添加，不要什么后缀名都写上去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">extensions</span>: [<span class="hljs-string">&quot;.warm&quot;</span>, <span class="hljs-string">&quot;.mjs&quot;</span>, <span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>],<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="给路径取别名-resolve-alias"><a href="#给路径取别名-resolve-alias" class="headerlink" title="给路径取别名 resolve.alias"></a>给路径取别名 resolve.alias</h2><p>我们引入文件时候经常存在..&#x2F;..&#x2F;..&#x2F;，我们可以配置 alias 可以减少查找过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&quot;@&quot;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&quot;./src&quot;</span>),<br>    &#125;,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h2><p>适合大项目</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">optimization</span>: &#123;<br>    <span class="hljs-attr">minimizer</span>: [<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">TerserPlugin</span>(&#123;<br>        <span class="hljs-attr">parallel</span>: <span class="hljs-literal">true</span>,<br>      &#125;),<br>    ],<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合理使用-sourceMap"><a href="#合理使用-sourceMap" class="headerlink" title="合理使用 sourceMap"></a>合理使用 sourceMap</h2><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041129524.png" alt="合理使用 sourceMap"></p>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP缓存机制</title>
    <link href="/http/cache/"/>
    <url>/http/cache/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-缓存机制"><a href="#HTTP-缓存机制" class="headerlink" title="HTTP 缓存机制"></a>HTTP 缓存机制</h1><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041119611.png" alt="强缓存流程"></p><p>涉及到字段：<br>● 请求返回 Expire 字段 http1.0 的产物，来设置过期时间，它是服务端生成，可能存在客户端和服务器端时间不一致，或者前端可以修改本地时间，导致缓存命中产生误差，目前基本都被 Cache-Control 替代了<br>● Cache-Control http1.1，一般使用 max-age 来设置缓存多长时间，单位秒；no-store 禁止一切缓存，no-cache 强制客户端向服务器发请求，服务器收到请求，然后判断内容是否变更，变更了就返回新内容，没有就返回 304；<strong>这个单词很容易误解，以为不缓存，其实是会被缓存的，只不过每次请求，都要服务端验证缓存。</strong></p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041120812.png" alt="协商缓存流程"></p><p>第一次请求数据：服务器会将缓存标识和数据返回给浏览器，然后将两者保存在缓存数据库中</p><p>再次发请求：浏览器会将标识发送给服务器检测，是否过期，如果没有过期，就返回 304 状态码，可以使用缓存数据，如果过期了，服务器重新响应数据。</p><p><strong>有两对字段配合检测缓存是否过期</strong></p><p>● Last-Modified &#x2F; If-Modified-Since：服务器响应的时候会返回，访问的资源最后修改的时间 Last-Modified，下一次请求的时候，会通过 If-Modified-Since 字段带上修改的时间，服务器回去对比资源修改的时间，如果不相同就说明修改过了，返回新的响应数据，重新缓存，如果相同就可以继续使用缓存，并返回 304 状态码。</p><p>● Etag &#x2F; If-None-Match（优先级高于 Last-Modified &#x2F; If-Modified-Since）：服务器响应的时候，会返回一个当前资源的标识（唯一的），下一次请求的时候，会通过 If-None-Match 字段带上这个标识，服务器去对比传过来的标识和当前资源的标识是否一致，如果不一致说明被修改过了，否则就可以继续使用缓存，并返回 304 状态码。</p><h2 id="为什么存在-Last-Modified-和-Etag-一起设置的情况？"><a href="#为什么存在-Last-Modified-和-Etag-一起设置的情况？" class="headerlink" title="为什么存在 Last-Modified 和 Etag 一起设置的情况？"></a>为什么存在 Last-Modified 和 Etag 一起设置的情况？</h2><p>Etag 和 Last-Modified 是允许一起使用的，服务器会优先验证 Etag，在 Etag 一致的情况下，再去对比 Last-Modified，这是为了防止有一些 HTTP 服务器未将文件修改日期纳入哈希范围内。</p><p>我们知道 Etag 是根据文件内容来生成哈希值的，ETag 的值，默认是对文件的索引节点（INode），大小（Size）和最后修改时间（MTime）进行 Hash 后得到的。假如我生成 Etag 生成策略不包含修改时间，改完后的内容索引节点和大小还是一样，其实内容变了，但是由于生成策略不包含修改时间，导致生成 Etag 一样了，所以还要通过 Last-Modified 字段来判断资源修改时间。</p><h2 id="为什么要有两种缓存呢？有了强缓存为什么还要有协商缓存？"><a href="#为什么要有两种缓存呢？有了强缓存为什么还要有协商缓存？" class="headerlink" title="为什么要有两种缓存呢？有了强缓存为什么还要有协商缓存？"></a>为什么要有两种缓存呢？有了强缓存为什么还要有协商缓存？</h2><p>因为强缓存有缺陷，假如通过 max-age 设置了过期时间，到了过期时间，但是其实内容并没有变更，就需要重新拉取资源，因此就有了 Last-Modified 字段，用来对比前后资源修改的时间，但是 Last-Modified 字段也有缺陷，因为它的时间是 s，如果 1s 内有资源修改了，它的修改时间是不会变的，所以还是会命中缓存的，不会重新获取资源的，最后就推出了 Etag，通过对比资源内容的来判断是否修改。</p><h2 id="HTTP-缓存整体流程图"><a href="#HTTP-缓存整体流程图" class="headerlink" title="HTTP 缓存整体流程图"></a>HTTP 缓存整体流程图</h2><p>强缓存优先级高于协商缓存</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041123957.png" alt="HTTP 缓存整体流程图"></p><p>参考文章：</p><ul><li><a href="https://cloud.tencent.com/developer/news/588770">从未如此简单：5 分钟搞懂 HTTP 缓存机制</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 批处理机制</title>
    <link href="/react/batch-update/"/>
    <url>/react/batch-update/</url>
    
    <content type="html"><![CDATA[<h1 id="React-批处理机制"><a href="#React-批处理机制" class="headerlink" title="React 批处理机制"></a>React 批处理机制</h1><p>我们开发过程中发现，调用 setState，然后获取 state 时候，发现不是最新的值，这是为什么呢？这就和 React 批处理机制有关系。<br>一次性调用好几次 setState，肯定不会调用一次组件就更新渲染一次，这样太消耗性能了。<br>react 做法，每次调用都记录下来，然后合并得到最新的值，最后才执行更新。<br>一般来说生命周期、react 事件里面都会命中批处理机制。<br>批处理的流程如下：</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041313403.png" alt="批处理机制"></p><div class="note note-warning">            <p>setState 本身并不是异步的，只不过批处理的机制，给人一种异步的假象。</p>          </div><p>分析一下整体流程：</p><p>● 当我们触发更新时候 setState<br>● 页面不会立即更新，而是把 state 存入 pendingState 队列中，要更新的组件存入 dirtyComponent 队列中。<br>● 是否开始更新，有个开关控制的 isBatchingUpdate，它是全局变量，如果为 false 才会进行更新。</p><div class="note note-info">            <p>什么时候为 false？<br>● 变量初始化时候（页面第一次渲染的时候）。<br>● 上一次更新执行完毕的时候。<br>● 为了 false 了，就把 dirtyComponent 中组件和 pendingState 的 state 进行更新，此时又把 isBatchingUpdate 设置为 true，这样就可以确保组件不会被重新渲染多次。</p>          </div><p>所以说下面的代码不会打印出最新的值，因为 state 都被缓存到 pendingState 里面了，要等批处理机制完成后才会统一更新的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;chenjiang&quot;</span> &#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><h2 id="为什么定时器里面和原生事件里面可以获取最新的值？"><a href="#为什么定时器里面和原生事件里面可以获取最新的值？" class="headerlink" title="为什么定时器里面和原生事件里面可以获取最新的值？"></a>为什么定时器里面和原生事件里面可以获取最新的值？</h2><blockquote><p>结论：异步代码，事件循环导致。</p></blockquote><p>上面提到了有个全局变量 isBatchingUpdate，默认是 false，更新开始设置为 true，更新结束为 false。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 假设点击按钮，执行了下面的代码。</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;调用 setState&quot;</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>    <span class="hljs-attr">index</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">index</span> + <span class="hljs-number">1</span>,<br>  &#125;);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;state&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">index</span>);<br>&#125;, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>分析一下上面的代码，为什么可以获取最新的值。</p><ol><li>一开始 isBatchingUpdate 为 false。</li><li>点击按钮执行了定时代码，由于 setTimeout 是异步代码，回调函数不会立即执行，要等同步代码执行完毕，进行事件循环的时候才会执行。</li><li>代码走完了，没有更新操作，isBatchingUpdate 也就不会设置为 true。</li><li>等到事件循环，执行定时器的回调函数，但是此时 isBatchingUpdate 是 false，就直接对 pendingState 和 dirtyComponent 进行更新，所以下面的 log 可以获取到最新的数据。（从上面流程图可以看出）</li></ol>]]></content>
    
    
    <categories>
      
      <category>React</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器渲染过程、回流、重绘</title>
    <link href="/browser/render/"/>
    <url>/browser/render/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器渲染过程、回流、重绘"><a href="#浏览器渲染过程、回流、重绘" class="headerlink" title="浏览器渲染过程、回流、重绘"></a>浏览器渲染过程、回流、重绘</h1><p>当浏览器收到 HTML 文档后，会产生一个渲染任务，并将其传递给<strong>渲染主线程</strong>得消息队列，在事件循环机制得作用下，渲染主线程将取出消息队列中得渲染任务，开启<strong>渲染流程</strong>。整个渲染分为多个阶段：<code>html解析</code>、<code>样式计算</code>、<code>布局</code>、<code>分层</code>、<code>绘制</code>、<code>分块</code>、<code>光栅化</code>、<code>画</code>，每个阶段都有明确的输入输出，上一个阶段的输出作为下一个阶段的输入。渲染流程如下：</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041015670.png" alt="渲染流程"></p><div class="note note-success">            <p>主线程主要就是把绘制信息弄出来，然后交给合成线程来真正画出来（主要是 GPU 操作）。</p>          </div><h2 id="渲染过程分解"><a href="#渲染过程分解" class="headerlink" title="渲染过程分解"></a>渲染过程分解</h2><h3 id="解析-HTML-文档"><a href="#解析-HTML-文档" class="headerlink" title="解析 HTML 文档"></a>解析 HTML 文档</h3><ol><li>解析过程中遇到 HTML 元素会解析 HTML 元素，最终生成 DOM 树</li><li>解析过程中遇到<code>style标签</code>、<code>link标签</code>、<code>行内样式</code>等 CSS 样式，会解析 CSS 会生成 CSSOM 树<div class="note note-info">            <p><strong>CSS 不会阻塞 HTML 解析</strong></p><p>如果主线程解析 HTML 过程中遇到了 link，此时外部的 CSS 还没有下载解析好，主线程不会等待，继续解析后面的 HTML。<strong>因为下载和解析 CSS 的工作是在</strong><code>预解析线程</code><strong>中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因.</strong></p><p><strong>JS 会阻塞 HTML 解析</strong></p><p>如果主线程遇到了 script，会停止解析，转而等待 JS 文件下载好，并将全局的代码解析执行完成后，才能继续解析 HTML。<strong>这是因为 JS 代码里面执行过程中可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</strong></p>          </div></li></ol><p>上面的步骤完成了，就会得到 DOM 树和 CSSOM 树（浏览器的默认样式、内部样式、外部样式、行内样式都会包含在 CSSOM 树中）。</p><h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>主线程会遍历 DOM 树，依次为树的每个节点计算出最终的样式，称为<code>computed style</code>，最终得到一颗带有样式的 DOM 树</p><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>依次遍历 DOM 树的每个节点，计算出几何位置。宽高、相对位置之类的，最终生成<code>布局树</code>。</p><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>主线程会使用一套复杂的策略对整个<code>布局树</code>进行分层。</p><ol><li>分层的好处，将来某一层发生改成，仅仅只用对这一层进行处理即可，从而提升效率。</li><li>滚动条、堆叠上下文、transform、opacity 等样式都会影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</li></ol><div class="note note-info">            <p>CSS 另一个名字“层叠样式表”，浏览器渲染出来的页面，其实一层一层的堆叠上去的。</p>          </div><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>主线程会对每个图层单独产生<code>绘制指令集</code>，用于描述这一层内容应该如何画出来。完成绘制过后，主线程会将每个图层的绘制信息交给<code>合成线程</code>。</p><h3 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h3><p>合成线程首先对每个图层进行分块，将其分层很多小区域。分块是多线程来进行，N 个分块器进行拆分。</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>合成线程将块的信息交给 GPU，以极高的速度完成光栅化。</p><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041021485.png" alt="光栅化"></p><p>GPU 会开启多线程来完成光栅化，并且优先处理靠近视口区域的块。</p><h3 id="画"><a href="#画" class="headerlink" title="画"></a>画</h3><p>合成线程拿到每个层、每个块的位图后，生成一个个指引的信息，里面包含了每个位图在屏幕的哪个位置，以及会考虑旋转、缩放等变形。</p><div class="note note-info">            <p>变形发生在合成线程，与主线程渲染无关，这就是<code>transform</code>效率高的根本原因。</p>          </div><p>合成线程会把指引信息交给 GPU，GPU 进行产生系统调用，最终提交给 GPU 硬件，完成最终的屏幕成像。一句话：合成线程把位图的信息交给 GPU，最终画出来。</p><h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041017382.png" alt="回流"></p><p>回流 reflow 主要的本质是重新计算<code>布局树</code>。</p><p>当我们进行<strong>影响布局的操作</strong>后，需要重新计算布局树，会引发 layout。</p><blockquote><p>影响布局的操作：增删 DOM 节点，修改元素的宽高、字体大小改变、border 变了等操作。</p></blockquote><p>为了避免连续的多次操作导致布局树重复计算，浏览器会合并这些操作，当 JS 代码全部完成过后再统一计算，所以，改动属性造成回流（reflow）是异步操作。</p><div class="note note-warning">            <p>注意：因为回流是异步操作，当 JS 获取布局属性时候，很有可能无法获取最新的布局信息。在浏览器反复权衡下，最终决定获取属性（scrollTop、offsetLeft、offsetWidth 等）立即回流（reflow）。</p>          </div><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041018871.png" alt="重绘"></p><p>重绘的本质就是重新根据分层信息计算绘制指令，是在 layer 这一步。<br>当改变了可见样式（背景、字体颜色），就需要重新计算，会引发 repaint。</p><div class="note note-danger">            <p>有上图可以看出来 layer 在 layout 后面，reflow 就是重新计算布局树，在 layout 这一步，因此回流（reflow）一定会引起重绘（repaint）。</p>          </div><h2 id="为什么-transform-效率高"><a href="#为什么-transform-效率高" class="headerlink" title="为什么 transform 效率高"></a>为什么 transform 效率高</h2><p><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041020329.png" alt="为什么 transform 效率高"></p><p>因为 transform 不会影响渲染主线程的步骤，它影响的只是渲染流程中最后一个步骤 draw 阶段。<br>由于 draw 阶段是在合成线程这种，所以 transform 的变化不会影响渲染主线程。</p><h2 id="如何减少回流、重绘"><a href="#如何减少回流、重绘" class="headerlink" title="如何减少回流、重绘"></a>如何减少回流、重绘</h2><ol><li>尽量使用 CSS 属性的简写：用 boder 代替 border-width、border-style、border-color。</li><li>批量修改元素样式，采用 class</li><li>需要创建多个 DOM 时候，使用 documentFragment。</li><li>尽量不要在 for 循环中获取元素的位置或者大小位置，这也会引起回流，如果一定要操作，最好利用缓存。</li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回流、重绘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript微任务、宏任务</title>
    <link href="/js/async-task/"/>
    <url>/js/async-task/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-微任务、宏任务"><a href="#JavaScript-微任务、宏任务" class="headerlink" title="JavaScript 微任务、宏任务"></a>JavaScript 微任务、宏任务</h1><h2 id="两大任务"><a href="#两大任务" class="headerlink" title="两大任务"></a>两大任务</h2><p>JavaScript 执行过程中会产生两大任务：同步任务、异步任务。</p><ul><li>同步任务：代码从上到下读取立即执行，例如声明语句、for、判断语句。</li><li>异步任务：异步任务又分为<code>微任务</code>，<code>宏任务</code>。例如 ajax、setTimout、Promise 等，代码从上到下执行，遇到这些异步代码，并不会立即执行，而是加入任务都队列，等待协调执行。</li></ul><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><div class="note note-default">            <p>常见的异步任务：</p><ul><li>宏任务（MacroTask）：script（JS 整体代码）、JavaScript 原生事件处理函数、定时器、requestAnimationFrame、MessageChannel 等</li><li>微任务：Promise、async、MutationObserver 等</li></ul>          </div><h3 id="任务队列执行过程"><a href="#任务队列执行过程" class="headerlink" title="任务队列执行过程"></a>任务队列执行过程</h3><p>执行完所有的同步任务过后，开始执行异步队列里面的任务，首先执行一个宏任务，如果在执行的过程中产生了宏任务、微任务，需要将他们加入到相应的任务队列当中，然后去执行（清空）微任务队列，执行完毕后，本次循环结束。<br>进入下一次循环，又执行一个微任务，以此类推，直到所有的任务都执行完毕。</p><p>整体流程图如下：<br><img src="https://cxkyyds.oss-cn-shenzhen.aliyuncs.com/blog-imgs/202409041709033.png" alt="任务队列执行过程"></p><p><a href="https://www.jsv9000.app/">JavaScript 可视化工具</a></p><h2 id="为什么要区分微任务和宏任务？"><a href="#为什么要区分微任务和宏任务？" class="headerlink" title="为什么要区分微任务和宏任务？"></a>为什么要区分微任务和宏任务？</h2><p>事件循环由宏任务和在执行宏任务期间产生的所有微任务组成。执行完当前这一个宏任务后，会立刻执行所有在此期间入队的微任务。</p><p>这种设计是为了给紧急任务一个插队的机会，否则新入队的任务永远被放在队尾。区分了微任务和宏任务后，本轮循环中的微任务实际上就是在插队，这样微任务中所做的状态修改，在下一轮事件循环中也能得到同步。</p><div class="note note-primary">            <p>● 微任务是线程之间的切换，速度快。不用进行上下文切换，可以快速的一次性做完所有的微任务。<br>● 宏任务是进程之间的切换，速度慢，且每次执行需要切换上下文。因此一个 Eventloop 中只执行一个宏任务。<br>● 微任务执行快，一次性可以执行很多个，在当前宏任务执行后立刻清空微任务可以达到伪同步的效果，这对视图渲染效果起到至关重要的作用。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[55dd097e5627d50208d4807ed296835a]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[google-site-verification: googlea838b242b1c61475.html]]></content>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[.category .collapsed .icon-arrowright {  padding-top: 4px;}#valine .vsys {  display: none;}]]></content>
    
  </entry>
  
  
  
  <entry>
    <title>关于我</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p>个人简介。。。</p>]]></content>
    
  </entry>
  
  
  
</search>
